"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registrationHandler = registrationHandler;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const oauth_js_1 = require("../schemas/oauth.js");
const errors_js_1 = require("../errors.js");
const allowedMethods_js_1 = require("../middleware/allowedMethods.js");
const descope_js_1 = require("../schemas/descope.js");
function formatDescopeError(status, errorBody) {
    const { errorDescription, errorCode } = errorBody;
    return `${status}${errorDescription ? ` - ${errorDescription}` : ""}${errorCode ? ` (${errorCode})` : ""}`;
}
function registrationHandler(provider) {
    // Nested router so we can configure middleware and restrict HTTP method
    const router = express_1.default.Router();
    // Configure CORS to allow any origin, to make accessible to web-based MCP clients
    router.use((0, cors_1.default)());
    router.use((0, allowedMethods_js_1.allowedMethods)(["POST"]));
    router.use(express_1.default.json());
    router.post("/", async (req, res) => {
        res.setHeader("Cache-Control", "no-store");
        try {
            if (!req.body || typeof req.body !== "object") {
                throw new errors_js_1.InvalidRequestError("Request body must be a JSON object");
            }
            const parseResult = oauth_js_1.OAuthClientMetadataSchema.safeParse(req.body);
            if (!parseResult.success) {
                throw new errors_js_1.InvalidClientMetadataError(parseResult.error.message);
            }
            const clientMetadata = parseResult.data;
            const clientInfo = await registerClient(clientMetadata, provider);
            res.status(201).json(clientInfo);
        }
        catch (error) {
            if (error instanceof errors_js_1.OAuthError) {
                const status = error instanceof errors_js_1.ServerError ? 500 : 400;
                res.status(status).json(error.toResponseObject());
            }
            else {
                console.error("Unexpected error registering client:", error);
                const serverError = new errors_js_1.ServerError("Internal Server Error");
                res.status(500).json(serverError.toResponseObject());
            }
        }
    });
    return router;
}
async function registerClient(client, provider) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { client_name, redirect_uris, logo_uri } = client;
    const createAppResponse = await fetch(`${provider.baseUrl}/v1/mgmt/thirdparty/app/create`, {
        headers: {
            Authorization: `Bearer ${provider.projectId}:${provider.managementKey}`,
            "Content-Type": "application/json",
        },
        method: "POST",
        body: JSON.stringify({
            name: client_name,
            approvedCallbackUrls: redirect_uris,
            logo: logo_uri || ((_a = provider.options.dynamicClientRegistrationOptions) === null || _a === void 0 ? void 0 : _a.logo),
            loginPageUrl: (_b = provider.options.dynamicClientRegistrationOptions) === null || _b === void 0 ? void 0 : _b.authPageUrl,
            permissionsScopes: (_d = (_c = provider.options.dynamicClientRegistrationOptions) === null || _c === void 0 ? void 0 : _c.permissionScopes) === null || _d === void 0 ? void 0 : _d.map(({ name, description, required, roles }) => ({
                name,
                description,
                optional: required !== true,
                values: roles,
            })),
            attributesScopes: (_f = (_e = provider.options.dynamicClientRegistrationOptions) === null || _e === void 0 ? void 0 : _e.attributeScopes) === null || _f === void 0 ? void 0 : _f.map(({ name, description, required, attributes }) => ({
                name,
                description,
                optional: required !== true,
                values: attributes,
            })),
            nonConfidentialClient: ((_g = provider.options.dynamicClientRegistrationOptions) === null || _g === void 0 ? void 0 : _g.nonConfidentialClient) === true,
        }),
    });
    if (!createAppResponse.ok) {
        const parsedError = descope_js_1.DescopeErrorResponseSchema.parse(await createAppResponse.json().catch(() => ({})));
        throw new errors_js_1.ServerError(`Failed to create app: ${formatDescopeError(createAppResponse.status, parsedError)}`);
    }
    const createAppResponseJson = (await createAppResponse.json());
    const appId = createAppResponseJson.id;
    const loadAppResponse = await fetch(`${provider.baseUrl}/v1/mgmt/thirdparty/app/load?id=${appId}`, {
        headers: {
            Authorization: `Bearer ${provider.projectId}:${provider.managementKey}`,
        },
        method: "GET",
    });
    if (!loadAppResponse.ok) {
        const parsedError = descope_js_1.DescopeErrorResponseSchema.parse(await loadAppResponse.json().catch(() => ({})));
        throw new errors_js_1.ServerError(`Failed to load app: ${formatDescopeError(loadAppResponse.status, parsedError)}`);
    }
    const loadAppResponseJson = (await loadAppResponse.json());
    const client_id = loadAppResponseJson.clientId;
    return oauth_js_1.OAuthClientInformationFullSchema.parse({
        client_id,
        ...client,
    });
}
//# sourceMappingURL=register.js.map