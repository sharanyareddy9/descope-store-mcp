"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMcpServerHandler = createMcpServerHandler;
const mcp_js_1 = require("@modelcontextprotocol/sdk/server/mcp.js");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
const requestContext_js_1 = require("../utils/requestContext.js");
/**
 * Creates an Express request handler that implements the MCP protocol
 * with Descope authentication integration.
 *
 * @param serverConfig - Configuration for the MCP server
 * @param toolRegistration - Function to register tools with the server
 * @param descopeConfig - Configuration for outbound token exchange
 *
 * @example
 * ```typescript
 * const mcpHandler = createMcpServerHandler(
 *   { name: "my-mcp-server", version: "1.0.0" },
 *   (server) => {
 *     const getUserTool = registerAuthenticatedTool({...});
 *     getUserTool(server);
 *   }
 * );
 *
 * app.post("/mcp", descopeMcpBearerAuth(), mcpHandler);
 * ```
 */
function createMcpServerHandler(serverConfig = {}, toolRegistration, descopeConfig) {
    const config = {
        name: serverConfig.name || "descope-mcp-server",
        version: serverConfig.version || "1.0.0",
        capabilities: serverConfig.capabilities || { logging: {} },
    };
    return async (req, res) => {
        const server = new mcp_js_1.McpServer(config, { capabilities: config.capabilities });
        // Get auth info from the authenticated request
        const authInfo = req.auth;
        // Attach request context to the server for this request lifecycle
        if (authInfo) {
            (0, requestContext_js_1.attachRequestContext)(server, authInfo, descopeConfig);
        }
        // Register tools if provided
        if (toolRegistration) {
            toolRegistration(server);
        }
        try {
            const transport = new streamableHttp_js_1.StreamableHTTPServerTransport({
                sessionIdGenerator: undefined,
            });
            await server.connect(transport);
            await transport.handleRequest(req, res, req.body);
            res.on("close", () => {
                transport.close();
                server.close();
            });
        }
        catch (error) {
            console.error("MCP server error:", error);
            res.status(500).json({
                jsonrpc: "2.0",
                error: {
                    code: -32603,
                    message: "Internal server error",
                },
                id: null,
            });
        }
    };
}
//# sourceMappingURL=mcpServer.js.map