"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthenticatedDescopeClient = createAuthenticatedDescopeClient;
exports.extractUserIdFromAuthInfo = extractUserIdFromAuthInfo;
exports.getOutboundToken = getOutboundToken;
exports.createOutboundTokenFactory = createOutboundTokenFactory;
const node_sdk_1 = __importDefault(require("@descope/node-sdk"));
/**
 * Creates an authenticated Descope client that includes the user's token in requests
 */
function createAuthenticatedDescopeClient(config, userToken) {
    return (0, node_sdk_1.default)({
        projectId: config.projectId,
        baseUrl: config.baseUrl,
        hooks: {
            beforeRequest: (requestConfig) => {
                requestConfig.headers = {
                    ...requestConfig.headers,
                    Authorization: `Bearer ${config.projectId}:${userToken}`,
                };
                return requestConfig;
            },
        },
    });
}
/**
 * Extracts user ID from the auth info token
 */
function extractUserIdFromAuthInfo(authInfo) {
    try {
        // Decode JWT token to extract user ID
        const tokenPayload = JSON.parse(Buffer.from(authInfo.token.split(".")[1], "base64").toString());
        // Try common user ID fields in order of preference
        return (tokenPayload.sub ||
            tokenPayload.userId ||
            tokenPayload.user_id ||
            tokenPayload.clientId);
    }
    catch (_a) {
        // Fallback to clientId if token parsing fails
        return authInfo.clientId;
    }
}
/**
 * Gets an outbound token for external API access using the authenticated user's context
 *
 * @param appId - The outbound application ID configured in Descope
 * @param authInfo - Authentication info from the authenticated tool
 * @param config - Descope configuration
 * @param scopes - Optional scopes to request for the outbound token
 * @returns The outbound token or null if exchange fails
 *
 * @example
 * ```typescript
 * const token = await getOutboundToken(
 *   'external-api-app',
 *   authInfo,
 *   { projectId: 'my-project' },
 *   ['read', 'write']
 * );
 * if (token) {
 *   // Use token to call external API
 *   const response = await fetch('https://api.example.com/data', {
 *     headers: { Authorization: `Bearer ${token}` }
 *   });
 * }
 * ```
 */
async function getOutboundToken(appId, authInfo, config, scopes) {
    var _a, _b;
    const userId = extractUserIdFromAuthInfo(authInfo);
    try {
        const descopeClient = createAuthenticatedDescopeClient(config, authInfo.token);
        const outbound = descopeClient.management.outboundApplication;
        const result = (scopes === null || scopes === void 0 ? void 0 : scopes.length)
            ? await outbound.fetchTokenByScopes(appId, userId, scopes)
            : await outbound.fetchToken(appId, userId);
        if (!result.ok) {
            console.error(`Failed to exchange token for app ${appId} for user ${userId}:`, result.error);
            return null;
        }
        return (_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.accessToken) !== null && _b !== void 0 ? _b : null;
    }
    catch (error) {
        console.error("Outbound token exchange error:", error instanceof Error ? error.message : "Token exchange failed");
        return null;
    }
}
/**
 * Factory function to create a getOutboundToken function bound to a specific configuration
 */
function createOutboundTokenFactory(config) {
    return (appId, authInfo, scopes) => getOutboundToken(appId, authInfo, config, scopes);
}
//# sourceMappingURL=outboundToken.js.map