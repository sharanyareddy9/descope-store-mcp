{"version":3,"file":"index.cjs.js","sources":["../../src/constants/apiPaths.ts","../../src/constants/index.ts","../../src/httpClient/helpers/createFetchLogger.ts","../../src/httpClient/helpers/getClientSessionId.ts","../../src/httpClient/types.ts","../../src/httpClient/urlBuilder.ts","../../src/httpClient/utils.ts","../../src/httpClient/index.ts","../../src/httpClient/helpers/index.ts","../../src/constants/httpStatusCodes.ts","../../src/sdk/helpers/index.ts","../../src/sdk/validations/core.ts","../../src/sdk/validations/validators.ts","../../src/sdk/validations/index.ts","../../src/sdk/accesskey.ts","../../src/utils/utils.ts","../../src/sdk/types.ts","../../src/sdk/enchantedLink/validations.ts","../../src/sdk/enchantedLink/index.ts","../../src/sdk/flow/index.ts","../../src/sdk/magicLink/validations.ts","../../src/sdk/magicLink/index.ts","../../src/sdk/oauth/types.ts","../../src/sdk/oauth/index.ts","../../src/sdk/outbound/validations.ts","../../src/sdk/outbound/index.ts","../../src/sdk/otp/index.ts","../../src/sdk/saml.ts","../../src/sdk/totp.ts","../../src/sdk/password/validations.ts","../../src/sdk/password/index.ts","../../src/sdk/webauthn.ts","../../src/sdk/notp/index.ts","../../src/sdk/index.ts","../../src/createSdk.ts","../../src/index.ts","../../src/utils/wrapWith/index.ts"],"sourcesContent":["/** API paths for the Descope service APIs */\nexport default {\n  accessKey: {\n    exchange: '/v1/auth/accesskey/exchange',\n  },\n  otp: {\n    verify: '/v1/auth/otp/verify',\n    signIn: '/v1/auth/otp/signin',\n    signUp: '/v1/auth/otp/signup',\n    update: {\n      email: '/v1/auth/otp/update/email',\n      phone: '/v1/auth/otp/update/phone',\n    },\n    signUpOrIn: '/v1/auth/otp/signup-in',\n  },\n  magicLink: {\n    verify: '/v1/auth/magiclink/verify',\n    signIn: '/v1/auth/magiclink/signin',\n    signUp: '/v1/auth/magiclink/signup',\n    update: {\n      email: '/v1/auth/magiclink/update/email',\n      phone: '/v1/auth/magiclink/update/phone',\n    },\n    signUpOrIn: '/v1/auth/magiclink/signup-in',\n  },\n  enchantedLink: {\n    verify: '/v1/auth/enchantedlink/verify',\n    signIn: '/v1/auth/enchantedlink/signin',\n    signUp: '/v1/auth/enchantedlink/signup',\n    session: '/v1/auth/enchantedlink/pending-session',\n    update: {\n      email: '/v1/auth/enchantedlink/update/email',\n    },\n    signUpOrIn: '/v1/auth/enchantedlink/signup-in',\n  },\n  oauth: {\n    start: '/v1/auth/oauth/authorize',\n    exchange: '/v1/auth/oauth/exchange',\n    startNative: 'v1/auth/oauth/native/start',\n    finishNative: 'v1/auth/oauth/native/finish',\n    oneTap: {\n      getOneTapClientId: '/v1/auth/onetap/clientid/{provider}',\n      exchangeOneTapIDToken: '/v1/auth/onetap/idtoken/exchange',\n      verifyOneTapIDToken: '/v1/auth/onetap/idtoken/verify',\n    },\n  },\n  outbound: {\n    connect: '/v1/outbound/oauth/connect',\n  },\n  saml: {\n    start: '/v1/auth/saml/authorize',\n    exchange: '/v1/auth/saml/exchange',\n  },\n  totp: {\n    verify: '/v1/auth/totp/verify',\n    signUp: '/v1/auth/totp/signup',\n    update: '/v1/auth/totp/update',\n  },\n  notp: {\n    signIn: '/v1/auth/notp/whatsapp/signin',\n    signUp: '/v1/auth/notp/whatsapp/signup',\n    signUpOrIn: '/v1/auth/notp/whatsapp/signup-in',\n    session: '/v1/auth/notp/pending-session',\n  },\n  webauthn: {\n    signUp: {\n      start: '/v1/auth/webauthn/signup/start',\n      finish: '/v1/auth/webauthn/signup/finish',\n    },\n    signIn: {\n      start: '/v1/auth/webauthn/signin/start',\n      finish: '/v1/auth/webauthn/signin/finish',\n    },\n    signUpOrIn: {\n      start: '/v1/auth/webauthn/signup-in/start',\n    },\n    update: {\n      start: 'v1/auth/webauthn/update/start',\n      finish: '/v1/auth/webauthn/update/finish',\n    },\n  },\n  password: {\n    signUp: '/v1/auth/password/signup',\n    signIn: '/v1/auth/password/signin',\n    sendReset: '/v1/auth/password/reset',\n    update: '/v1/auth/password/update',\n    replace: '/v1/auth/password/replace',\n    policy: '/v1/auth/password/policy',\n  },\n  refresh: '/v1/auth/refresh',\n  tryRefresh: '/v1/auth/try-refresh',\n  selectTenant: '/v1/auth/tenant/select',\n  logout: '/v1/auth/logout',\n  logoutAll: '/v1/auth/logoutall',\n  me: '/v1/auth/me',\n  myTenants: '/v1/auth/me/tenants',\n  history: '/v1/auth/me/history',\n  flow: {\n    start: '/v1/flow/start',\n    next: '/v1/flow/next',\n  },\n};\n","/** Default Descope API URL */\nexport const BASE_URL_REGION_PLACEHOLDER = '<region>';\nexport const DEFAULT_BASE_API_URL = `https://api.${BASE_URL_REGION_PLACEHOLDER}descope.com`;\n\n/** Default magic link polling interval for checking if the user clicked on the magic-link/enchanted-link/notp */\nexport const MIN_POLLING_INTERVAL_MS = 1000; // 1 second\n/** Default maximum time we are willing to wait for the magic-link/enchanted-link/notp to be clicked */\nexport const MAX_POLLING_TIMEOUT_MS = 1000 * 60 * 10; // 10 minutes\n\n/**  Descope current tenant claim */\nexport const DESCOPE_CURRENT_TENANT_CLAIM = 'dct';\n\n/** API paths to the Descope service */\nexport { default as apiPaths } from './apiPaths';\n","import { Logger } from '../../sdk/types';\nimport { Fetch } from '../types';\n\n/** Build a log message around HTTP calls  */\nconst httpLogBuilder = () => {\n  const msg: {\n    Title?: string;\n    Url?: string;\n    Method?: string;\n    Headers?: string;\n    Body?: string;\n    Status?: string;\n    Retries?: number;\n  } = {};\n\n  return {\n    headers(headers: HeadersInit) {\n      const headersObj =\n        typeof headers.entries === 'function'\n          ? Object.fromEntries(headers.entries())\n          : headers;\n      msg.Headers = JSON.stringify(headersObj);\n\n      return this;\n    },\n\n    body(body: string) {\n      msg.Body = body;\n      return this;\n    },\n\n    url(url: URL | string) {\n      msg.Url = url.toString();\n      return this;\n    },\n\n    method(method: string) {\n      msg.Method = method;\n      return this;\n    },\n\n    title(title: string) {\n      msg.Title = title;\n      return this;\n    },\n\n    status(status: string) {\n      msg.Status = status;\n      return this;\n    },\n\n    retries(retries: number) {\n      msg.Retries = retries;\n      return this;\n    },\n\n    build() {\n      return Object.keys(msg)\n        .flatMap((key) =>\n          msg[key] ? [`${key !== 'Title' ? `${key}: ` : ''}${msg[key]}`] : [],\n        )\n        .join('\\n');\n    },\n  };\n};\n\n/** Log the request object */\nconst buildRequestLog = (args: Parameters<Fetch>) =>\n  httpLogBuilder()\n    .title('Request')\n    .url(args[0])\n    .method(args[1].method)\n    .headers(args[1].headers)\n    .body(args[1].body)\n    .build();\n\n// we should retry once in case we got these status codes:\n// 521: Web Server Is Down (Cloudflare error)\n// 524: A Timeout Occurred (Cloudflare error)\nconst retryStatusCodes = [521, 524];\n\n/** Log the response object */\nconst buildResponseLog = async (resp: Response & { retries?: number }) => {\n  const respBody = await resp.text();\n\n  return httpLogBuilder()\n    .title('Response')\n    .url(resp.url.toString())\n    .status(`${resp.status} ${resp.statusText}`)\n    .headers(resp.headers)\n    .body(respBody)\n    .retries(resp.retries)\n    .build();\n};\n\nconst fetchWrapper =\n  (fetch: Fetch) =>\n  async (...args: Parameters<Fetch>) => {\n    let resp: Response & { retries?: number } = await fetch(...args);\n\n    if (retryStatusCodes.includes(resp.status)) {\n      resp = await fetch(...args);\n      resp.retries = 1;\n    }\n\n    // we found out that cloning the response is problematic when using node fetch\n    // so instead, we are reading the body stream once and overriding the clone, text & json functions\n    const respText = await resp.text();\n\n    resp.text = () => Promise.resolve(respText);\n    resp.json = () => Promise.resolve(JSON.parse(respText));\n    resp.clone = () => resp;\n\n    return resp;\n  };\n\n/**\n * Create a fetch with a logger wrapped around it if a logger is given\n * @param logger Logger to send the logs to\n * @param receivedFetch Fetch to be used or built-in fetch if not provided\n *\n */\nconst createFetchLogger = (logger: Logger, receivedFetch?: Fetch) => {\n  const baseFetch = receivedFetch || fetch;\n  if (!baseFetch)\n    // eslint-disable-next-line no-console\n    logger?.warn(\n      'Fetch is not defined, you will not be able to send http requests, if you are running in a test, make sure fetch is defined globally',\n    );\n\n  if (!logger) return fetchWrapper(baseFetch);\n  return async (...args: Parameters<Fetch>) => {\n    if (!baseFetch)\n      throw Error(\n        'Cannot send http request, fetch is not defined, if you are running in a test, make sure fetch is defined globally',\n      );\n    logger.log(buildRequestLog(args));\n    const resp = await fetchWrapper(baseFetch)(...args);\n\n    logger[resp.ok ? 'log' : 'error'](await buildResponseLog(resp));\n\n    return resp;\n  };\n};\n\nexport default createFetchLogger;\n","let sessionId: string;\n\nexport const getClientSessionId = (): string => {\n  if (sessionId) {\n    return sessionId;\n  }\n  const currentDate = new Date();\n  const utcString = `${currentDate.getUTCFullYear().toString()}-${(\n    currentDate.getUTCMonth() + 1\n  )\n    .toString()\n    .padStart(2, '0')}-${currentDate\n    .getUTCDate()\n    .toString()\n    .padStart(2, '0')}-${currentDate\n    .getUTCHours()\n    .toString()\n    .padStart(2, '0')}:${currentDate\n    .getUTCMinutes()\n    .toString()\n    .padStart(2, '0')}:${currentDate\n    .getUTCSeconds()\n    .toString()\n    .padStart(2, '0')}:${currentDate.getUTCMilliseconds().toString()}`;\n  const randomSuffix = Math.floor(1000 + Math.random() * 9000);\n  sessionId = `${utcString}-${randomSuffix}`;\n  return sessionId;\n};\n","import { Logger } from '../sdk/types';\n\n/** Request configuration including headers, query params and token */\ntype HttpClientReqConfig = {\n  headers?: HeadersInit;\n  queryParams?: { [key: string]: string };\n  token?: string;\n};\n\nexport type ExtendedResponse = Response & { cookies: Record<string, string> };\n\n/** HTTP methods we use in the client */\nexport enum HTTPMethods {\n  get = 'GET',\n  delete = 'DELETE',\n  post = 'POST',\n  put = 'PUT',\n  patch = 'PATCH',\n}\n\n/** HTTP Client type that implements the HTTP method calls. Descopers can provide their own HTTP client although required only in rare cases. */\nexport type HttpClient = {\n  get: (path: string, config?: HttpClientReqConfig) => Promise<Response>;\n  post: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig,\n  ) => Promise<Response>;\n  patch: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig,\n  ) => Promise<Response>;\n  put: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig,\n  ) => Promise<Response>;\n  delete: (path: string, config?: HttpClientReqConfig) => Promise<Response>;\n  hooks?: Hooks;\n  buildUrl: (path: string, queryParams?: { [key: string]: string }) => string;\n};\n\nexport type Fetch = typeof fetch;\n\n/** Parameters for the HTTP client. Defaults should work for most cases. */\nexport type CreateHttpClientConfig = {\n  baseUrl?: string;\n  projectId: string;\n  baseConfig?: { baseHeaders: HeadersInit };\n  logger?: Logger;\n  hooks?: Hooks;\n  cookiePolicy?: RequestCredentials | null;\n  refreshCookieName?: string;\n  fetch?: Fetch;\n};\n\n/** For before-request hook allows overriding parts of the request */\nexport type RequestConfig = {\n  path: string;\n  headers?: HeadersInit;\n  queryParams?: { [key: string]: string };\n  body?: any;\n  method: HTTPMethods;\n  token?: string;\n};\n\nexport type BeforeRequest = (config: RequestConfig) => RequestConfig;\n\nexport type AfterRequest = (\n  req: RequestConfig,\n  res: Response,\n) => void | Promise<void>;\n\n/** Hooks before and after the request is made */\nexport type Hooks = {\n  beforeRequest?: BeforeRequest;\n  afterRequest?: AfterRequest;\n  transformResponse?: (\n    mutableResponse: ExtendedResponse,\n  ) => Promise<ExtendedResponse>;\n};\n\nexport type MultipleHooks = {\n  beforeRequest?: BeforeRequest | BeforeRequest[];\n  afterRequest?: AfterRequest | AfterRequest[];\n  transformResponse?: (\n    mutableResponse: ExtendedResponse,\n  ) => Promise<ExtendedResponse>;\n};\n","import { BASE_URL_REGION_PLACEHOLDER } from '../constants';\n\n/** Build URL with given parts */\nexport const urlBuilder = ({\n  path,\n  baseUrl,\n  queryParams,\n  projectId,\n}: {\n  path: string;\n  baseUrl: string;\n  queryParams?: { [key: string]: string };\n  projectId: string;\n}) => {\n  // NOTE: many URL and URLSearchParams functions and fields are NOT SUPPORTED by the react-native runtime.\n  // To add insult to injury - it adds a trailing slash almost no matter what the input is:\n  // https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Blob/URL.js#L144\n  // Do not replace unless testing with all of the core-dependent projects\n  const region = projectId.slice(1, -27);\n  baseUrl = baseUrl.replace(\n    BASE_URL_REGION_PLACEHOLDER,\n    region ? region + '.' : '',\n  );\n  // append path to base\n  let url = path\n    ? `${baseUrl.replace(/\\/$/, '')}/${path?.replace(/^\\//, '')}`\n    : baseUrl;\n\n  // add query params if given\n  if (queryParams) {\n    const keys = Object.keys(queryParams);\n    keys.forEach((key: string, index: number) => {\n      url = `${url}${index === 0 ? '?' : ''}${key}=${encodeURIComponent(\n        queryParams[key],\n      )}${index === keys.length - 1 ? '' : '&'}`;\n    });\n  }\n\n  return url;\n};\n","/* eslint-disable no-nested-ternary */\n\ntype SdkHeaders = HeadersInit | Record<string, () => string>;\n\nconst getSrcArr = (source: SdkHeaders) => {\n  if (Array.isArray(source)) return source;\n  if (source instanceof Headers) return Array.from(source.entries());\n  if (!source) return [];\n  return Object.entries(source);\n};\n\n/** Merge the given list of headers into a single Headers object */\nexport const mergeHeaders = (...sources: SdkHeaders[]) =>\n  new Headers(\n    sources.reduce<Record<string, string>>(\n      (acc: Record<string, string>, source) => {\n        getSrcArr(source).forEach(([key, value]) => {\n          acc[key] = typeof value === 'function' ? value() : value;\n        });\n\n        return acc;\n      },\n      {},\n    ),\n  );\n\n/** Serialize the body to JSON */\nexport const serializeBody = (body: Record<string, any>) =>\n  body === undefined ? undefined : JSON.stringify(body);\n","import { DEFAULT_BASE_API_URL } from '../constants';\nimport { getClientSessionId, transformSetCookie } from './helpers';\nimport createFetchLogger from './helpers/createFetchLogger';\nimport {\n  AfterRequest,\n  BeforeRequest,\n  CreateHttpClientConfig,\n  HttpClient,\n  HTTPMethods,\n  MultipleHooks,\n  RequestConfig,\n} from './types';\nimport { urlBuilder } from './urlBuilder';\nimport { mergeHeaders, serializeBody } from './utils';\n\nconst jsonHeaders = {\n  'Content-Type': 'application/json',\n};\n\n/**\n * Create a Bearer authorization header with concatenated projectId and token\n * @param projectId The project id to use in the header\n * @param token Token to be concatenated. Defaults to empty.\n */\nconst createAuthorizationHeader = (\n  projectId: string,\n  token = '',\n): Record<string, string> => {\n  let bearer = projectId;\n  if (token) {\n    bearer = bearer + ':' + token;\n  }\n  return {\n    Authorization: `Bearer ${bearer}`,\n  };\n};\n\ndeclare const BUILD_VERSION: string;\n\n/**\n * Create descope custom headers\n */\nconst createDescopeHeaders = (\n  projectId: string,\n  refreshCookieName?: string,\n) => {\n  const res = {\n    'x-descope-sdk-session-id': getClientSessionId(),\n    'x-descope-sdk-name': 'core-js',\n    'x-descope-sdk-version': BUILD_VERSION,\n    'x-descope-project-id': projectId,\n  };\n\n  if (refreshCookieName) {\n    res['x-descope-refresh-cookie-name'] = refreshCookieName;\n  }\n  return res;\n};\n\nconst isJson = (value?: string) => {\n  try {\n    value = JSON.parse(value);\n  } catch (e) {\n    return false;\n  }\n\n  return typeof value === 'object' && value !== null;\n};\n\n/** Add the ability to pass multiple hooks instead of one when creating an http client */\nconst withMultipleHooks =\n  <T extends object>(createHttpClient: (config: CreateHttpClientConfig) => T) =>\n  (\n    config: Omit<CreateHttpClientConfig, 'hooks'> & { hooks?: MultipleHooks },\n  ) => {\n    const beforeRequest: BeforeRequest = (conf) => {\n      // get the before hooks from the config while function is running\n      // because the hooks might change after sdk creation\n      const beforeRequestHooks = [].concat(config.hooks?.beforeRequest || []);\n      return beforeRequestHooks?.reduce((acc, fn) => fn(acc), conf);\n    };\n\n    const afterRequest: AfterRequest = async (req, res) => {\n      // get the after hooks from the config while function is running\n      // because the hooks might change after sdk creation\n      const afterRequestHooks = [].concat(config.hooks?.afterRequest || []);\n      // do not remove this check - on old versions of react-native it is required\n      if (afterRequestHooks.length == 0) return;\n      const results = await Promise.allSettled(\n        afterRequestHooks?.map((fn) => fn(req, res?.clone())),\n      );\n      // eslint-disable-next-line no-console\n      results.forEach(\n        (result) =>\n          result.status === 'rejected' && config.logger?.error(result.reason),\n      );\n    };\n\n    return createHttpClient({\n      ...config,\n      hooks: {\n        beforeRequest,\n        afterRequest,\n        transformResponse: config.hooks?.transformResponse,\n      },\n    });\n  };\n\n/**\n * Create the HTTP client used to send HTTP requests to the Descope API\n *\n * @param CreateHttpClientConfig Configuration for the client\n */\nconst createHttpClient = ({\n  baseUrl: recBaseUrl,\n  projectId,\n  baseConfig,\n  refreshCookieName,\n  logger,\n  hooks,\n  cookiePolicy,\n  fetch,\n}: CreateHttpClientConfig): HttpClient => {\n  const baseUrl = recBaseUrl || DEFAULT_BASE_API_URL;\n  const fetchWithLogger = createFetchLogger(logger, fetch);\n\n  const sendRequest = async (config: RequestConfig) => {\n    const requestConfig = hooks?.beforeRequest\n      ? hooks.beforeRequest(config)\n      : config;\n\n    const { path, body, headers, queryParams, method, token } = requestConfig;\n\n    const serializedBody = serializeBody(body);\n    const requestInit: RequestInit = {\n      headers: mergeHeaders(\n        createAuthorizationHeader(projectId, token),\n        createDescopeHeaders(projectId, refreshCookieName),\n        baseConfig?.baseHeaders || {},\n        isJson(serializedBody) ? jsonHeaders : {}, // add json content headers if body is json\n        headers,\n      ),\n      method,\n      body: serializedBody,\n    };\n\n    // On edge runtimes like Cloudflare, the fetch implementation does not support credentials\n    // so we allow the caller to omit by specifying null\n    // See https://github.com/cloudflare/workerd/blob/main/src/workerd/api/http.h#L591\n    if (cookiePolicy !== null) {\n      requestInit.credentials = cookiePolicy || 'include';\n    }\n\n    const res = await fetchWithLogger(\n      urlBuilder({ path, baseUrl, queryParams, projectId }),\n      requestInit,\n    );\n\n    if (hooks?.afterRequest) {\n      await hooks.afterRequest(config, res?.clone());\n    }\n\n    if (hooks?.transformResponse) {\n      const json = await res.json();\n      const cookies = transformSetCookie(res.headers?.get('set-cookie') || '');\n      const mutableResponse = {\n        ...res,\n        json: () => Promise.resolve(json),\n        cookies,\n      };\n      // we want to make sure cloning the response will keep the transformed json data\n      mutableResponse.clone = () => mutableResponse;\n      return hooks.transformResponse(mutableResponse);\n    }\n\n    return res;\n  };\n\n  return {\n    get: (path: string, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body: undefined,\n        method: HTTPMethods.get,\n        token,\n      }),\n    post: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.post,\n        token,\n      }),\n    patch: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.patch,\n        token,\n      }),\n    put: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.put,\n        token,\n      }),\n    delete: (path, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body: undefined,\n        method: HTTPMethods.delete,\n        token,\n      }),\n    hooks,\n    buildUrl: (path, queryParams) => {\n      return urlBuilder({ projectId, baseUrl, path, queryParams });\n    },\n  };\n};\n\nexport default withMultipleHooks(createHttpClient);\nexport type { HttpClient };\n","export { default as createFetchLogger } from './createFetchLogger';\nexport { getClientSessionId } from './getClientSessionId';\n\nexport function transformSetCookie(setCookieHeader: string) {\n  // Split the header by semicolons to separate different attributes\n  var cookiesString = setCookieHeader.split(';');\n\n  return cookiesString.reduce((acc, cookie) => {\n    const [key, value] = cookie.split('=');\n    return {\n      ...acc,\n      [key.trim()]: value,\n    };\n  }, {});\n}\n","export default {\n  TOO_MANY_REQUESTS: 429,\n};\n","import { jwtDecode, JwtPayload } from 'jwt-decode';\nimport { ResponseData, SdkResponse } from '../types';\nimport HttpStatusCodes from '../../constants/httpStatusCodes';\nimport { DESCOPE_CURRENT_TENANT_CLAIM } from '../../constants';\n\nfunction getJwtAuthorizationItems(\n  token: string,\n  tenant: string,\n  claim: string,\n): string[] {\n  let claims: any = parseJwt(token);\n  if (tenant) {\n    if (!claims?.tenants && claims?.[DESCOPE_CURRENT_TENANT_CLAIM] === tenant) {\n      // The token may have the current tenant in the \"dct\" claim and without the \"tenants\" claim\n      return claims?.[claim] || [];\n    } else {\n      claims = claims?.tenants?.[tenant];\n    }\n  }\n  const items = claims?.[claim];\n  return Array.isArray(items) ? items : [];\n}\n\nfunction parseJwt(token: string): JwtPayload {\n  if (typeof token !== 'string' || !token)\n    throw new Error('Invalid token provided');\n  return jwtDecode(token);\n}\n\n/**\n * Checks if the given JWT is still valid but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function isJwtExpired(token: string): boolean {\n  const { exp } = parseJwt(token);\n  const currentTime = new Date().getTime() / 1000;\n  return currentTime > exp;\n}\n\n/**\n * Returns the list of tenants in the given JWT\n *\n * @param token JWT token\n */\nexport function getTenants(token: string): string[] {\n  let claims: any = parseJwt(token);\n  const items = Object.keys(claims?.tenants);\n  return Array.isArray(items) ? items : [];\n}\n\n/**\n * Returns the list of permissions granted in the given JWT but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function getJwtPermissions(token: string, tenant?: string): string[] {\n  return getJwtAuthorizationItems(token, tenant, 'permissions');\n}\n\n/**\n * Returns the list of roles specified in the given JWT but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function getJwtRoles(token: string, tenant?: string): string[] {\n  return getJwtAuthorizationItems(token, tenant, 'roles');\n}\n\n/** Joins path parts making sure there is only one path separator between parts */\nexport const pathJoin = (...args: string[]) =>\n  args.join('/').replace(/\\/{2,}/g, '/');\n\n/** Transform the Promise Response to our internal SdkResponse implementation\n * @param response The Response promise from fetch\n * @param transform Optionally transform the response JSON to another type\n */\nexport async function transformResponse<\n  T extends ResponseData,\n  S extends ResponseData = T,\n>(\n  response: Promise<Response>,\n  transform?: (data: T) => S,\n): Promise<SdkResponse<S>> {\n  const resp = await response;\n\n  const ret: SdkResponse<S> = {\n    code: resp.status,\n    ok: resp.ok,\n    response: resp,\n  };\n\n  const data = await resp.clone().json();\n\n  if (!resp.ok) {\n    ret.error = data;\n\n    if (resp.status === HttpStatusCodes.TOO_MANY_REQUESTS) {\n      Object.assign(ret.error, {\n        retryAfter: Number.parseInt(resp.headers?.get('retry-after')) || 0,\n      });\n    }\n  } else if (transform) {\n    ret.data = transform(data);\n  } else {\n    ret.data = <S>data;\n  }\n\n  return ret;\n}\n\nexport function getCurrentTenant(token: string): string {\n  return parseJwt(token)?.[DESCOPE_CURRENT_TENANT_CLAIM] || '';\n}\n","import { Validator, ValidationRule, MakeValidator } from './types';\n\nexport const createValidator =\n  (rule: ValidationRule, defaultMsg?: string): MakeValidator =>\n  (msg = defaultMsg) =>\n  (val) =>\n    !rule(val) ? msg.replace('{val}', val) : false;\n\nexport const createOrValidator =\n  (validators: Validator[], defaultMsg?: string): MakeValidator =>\n  (msg = defaultMsg) =>\n  (val) => {\n    const errors = validators.filter((validator) => validator(val));\n\n    if (errors.length < validators.length) return false;\n\n    return msg ? msg.replace('{val}', val) : errors.join(' OR ');\n  };\n\nexport const createValidation = (...validators: Validator[]) => ({\n  validate: (val: any) => {\n    validators.forEach((validator) => {\n      const errMsg = validator(val);\n      if (errMsg) throw new Error(errMsg);\n    });\n\n    return true;\n  },\n});\n","import { createOrValidator, createValidation, createValidator } from './core';\nimport { Validator } from './types';\n\nconst regexMatch = (regex: RegExp) => (val: any) => regex.test(val);\n\nconst validateString = (val: any) => typeof val === 'string';\n\nconst validateArray = (val: any) => Array.isArray(val);\n\nconst validateBoolean = (val: any) => typeof val === 'boolean';\n\nconst validateUndefined = (val: any) => val === undefined;\n\nconst validateEmail = regexMatch(\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/,\n);\n\n// A replacement for lodash.get, because it may not integrate well in various runtime environments (Edge).\n// Implementation is based on https://gist.github.com/dfkaye/59263b51cf1e0b633181c5f44ae2066a\nconst get = (object: any, pathName: string, defaultValue?: any) => {\n  // Coerce pathName to a string (even it turns into \"[object Object]\").\n  const path = Array.isArray(pathName) ? pathName.join('.') : String(pathName);\n\n  // Support bracket notation, e.g., \"a[0].b.c\".\n  const match = /\\[\\\\?(\"|')?(\\w|d)+\\\\?(\"|')?\\]/g;\n\n  const parts = path.replace(match, (m, i, v) => '.' + v).split('.');\n\n  const length = parts.length;\n  let i = 0;\n\n  // In case object isn't a real object, set it to undefined.\n  let value = object === Object(object) ? object : undefined;\n\n  while (value != null && i < length) {\n    value = value[parts[i++]];\n  }\n\n  /**\n   * returns the resolved value if\n   * 1. iteration happened (i > 0)\n   * 2. iteration completed (i === length)\n   * 3. the value at the path is found in the data structure (not undefined). Note that if the path is found but the\n   *    value is null, then null is returned.\n   * If any of those checks fails, return the defaultValue param, if provided.\n   */\n  return i && i === length && value !== undefined ? value : defaultValue;\n};\n\nconst validatePhone = regexMatch(/^\\+[1-9]{1}[0-9]{3,14}$/);\nconst validateMinLength = (min: number) => (val: any) => val.length >= min;\n// const validatePlainObject = (val: any) => !!val && Object.getPrototypeOf(val) === Object.prototype;\nconst validatePathValue = (path: string, rules: Validator[]) => (val: any) =>\n  createValidation(...rules).validate(get(val, path));\n\nexport const isEmail = createValidator(\n  validateEmail,\n  '\"{val}\" is not a valid email',\n);\nexport const isPhone = createValidator(\n  validatePhone,\n  '\"{val}\" is not a valid phone number',\n);\nexport const isNotEmpty = createValidator(\n  validateMinLength(1),\n  'Minimum length is 1',\n);\nexport const isString = createValidator(\n  validateString,\n  'Input is not a string',\n);\n\nexport const isArray = createValidator(validateArray, 'Input is not an array');\n\nexport const isBoolean = createValidator(\n  validateBoolean,\n  'Input is not a boolean',\n);\n\nexport const isUndefined = createValidator(\n  validateUndefined,\n  'Input is defined',\n);\n\nexport const isStringOrUndefined = createOrValidator(\n  [isString(), isUndefined()],\n  'Input is not a string or undefined',\n);\n\nexport const isArrayOrBool = createOrValidator(\n  [isArray(), isBoolean()],\n  'Input is not an array or boolean',\n);\n\n// export const isPlainObject = createValidator(validatePlainObject, 'Input is not a plain object');\nexport const hasPathValue = (path: string, rules: Validator[]) =>\n  createValidator(validatePathValue(path, rules))();\n","import { createValidation } from './core';\nimport { Validator } from './types';\nimport {\n  isEmail,\n  isNotEmpty,\n  isPhone,\n  isString,\n  isStringOrUndefined,\n} from './validators';\n\n/**\n *\n * Validate that all of the validators passes\n * @params each parameter is an array of validators, those validators will be verified against the wrapped function argument which in the same place\n * @throws if any of the validators fails, an error with the relevant message will be thrown\n */\nexport const withValidations =\n  (...argsRules: Validator[][]) =>\n  <T extends Array<any>, U>(fn: (...args: T) => U) =>\n  (...args: T): U => {\n    argsRules.forEach((rulesArr, i) =>\n      createValidation(...rulesArr).validate(args[i]),\n    );\n\n    return fn(...args);\n  };\n\nexport const string = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n];\n\nexport const isStringOrUndefinedValidator = (fieldName: string) => [\n  isStringOrUndefined(`\"${fieldName}\" must be string or undefined`),\n];\n\nexport const stringNonEmpty = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isNotEmpty(`\"${fieldName}\" must not be empty`),\n];\nexport const stringEmail = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isEmail(),\n];\nexport const stringPhone = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isPhone(),\n];\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  AccessKeyLoginOptions,\n  ExchangeAccessKeyResponse,\n  SdkResponse,\n} from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst withExchangeValidations = withValidations(stringNonEmpty('accessKey'));\n\nconst withAccessKeys = (httpClient: HttpClient) => ({\n  exchange: withExchangeValidations(\n    (\n      accessKey: string,\n      loginOptions?: AccessKeyLoginOptions,\n    ): Promise<SdkResponse<ExchangeAccessKeyResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.accessKey.exchange,\n          { loginOptions },\n          { token: accessKey },\n        ),\n      ),\n  ),\n});\n\nexport default withAccessKeys;\n","import { MAX_POLLING_TIMEOUT_MS, MIN_POLLING_INTERVAL_MS } from '../constants';\n\n/** Polling configuration with defaults and normalizing checks */\nexport const normalizeWaitForSessionConfig = ({\n  pollingIntervalMs = MIN_POLLING_INTERVAL_MS,\n  timeoutMs = MAX_POLLING_TIMEOUT_MS,\n} = {}) => ({\n  pollingIntervalMs: Math.max(\n    pollingIntervalMs || MIN_POLLING_INTERVAL_MS,\n    MIN_POLLING_INTERVAL_MS,\n  ),\n  timeoutMs: Math.min(\n    timeoutMs || MAX_POLLING_TIMEOUT_MS,\n    MAX_POLLING_TIMEOUT_MS,\n  ),\n});\n","type DeviceInfo = {\n  webAuthnSupport?: boolean;\n};\n\ntype LastAuth = {\n  authMethod?: AuthMethod;\n  oauthProvider?: string;\n  name?: string;\n  loginId?: string;\n};\n\ntype RedirectAuth = {\n  callbackUrl: string;\n  codeChallenge: string;\n};\n\n/** Sent in a flow start request when running as a native flow component via a mobile SDK */\ntype NativeOptions = {\n  /** What mobile platform we're running on, used to decide between different behaviors on the backend */\n  platform: 'ios' | 'android';\n\n  /** The name of an OAuth provider that will use native OAuth (Sign in with Apple/Google) instead of web OAuth when running in a mobile app */\n  oauthProvider?: string;\n\n  /** An override for web OAuth that sets the address to redirect to after authentication succeeds at the OAuth provider website */\n  oauthRedirect?: string;\n};\n\ntype AuthMethod =\n  | 'magiclink'\n  | 'enchantedlink'\n  | 'otp'\n  | 'totp'\n  | 'oauth'\n  | 'saml'\n  | 'webauthn';\n\nexport type SdkFn = (...args: any[]) => Promise<SdkResponse<ResponseData>>;\n\nexport type MaskedPhone = {\n  maskedPhone: string;\n};\n\nexport type MaskedEmail = {\n  maskedEmail: string;\n};\n\n/** User base details from Descope API */\nexport type User = {\n  email?: string;\n  name?: string;\n  givenName?: string;\n  middleName?: string;\n  familyName?: string;\n  phone?: string;\n};\n\n/** User extended details from Descope API */\nexport type UserResponse = User & {\n  loginIds: string[];\n  userId: string;\n  verifiedEmail?: boolean;\n  verifiedPhone?: boolean;\n  picture?: string;\n  roleNames?: string[];\n  userTenants?: UserTenant[];\n  createdTime: number;\n  TOTP: boolean;\n  SAML: boolean;\n  SCIM: boolean;\n  password: boolean;\n  OAuth?: Record<string, boolean>;\n  customAttributes?: Record<string, any>;\n  status: string;\n};\n\nexport type Tenant = {\n  id: string;\n  name: string;\n  customAttributes?: Record<string, any>;\n};\n\nexport type TenantsResponse = {\n  tenants: Tenant[];\n};\n\nexport type UserHistoryResponse = {\n  userId: string;\n  loginTime: number;\n  city: string;\n  country: string;\n  ip: string;\n};\n\n/** A tenant association mapping  */\nexport type UserTenant = {\n  tenantId: string;\n  roleNames?: string[];\n  tenantName: string;\n};\n\nexport type TemplateOptions = Record<string, string>; // for providing messaging template options (templates that are being sent via email / text message)\n\n/** Login options to be added to the different authentication methods */\nexport type LoginOptions = {\n  stepup?: boolean;\n  mfa?: boolean;\n  revokeOtherSessions?: boolean;\n  customClaims?: Record<string, any>;\n  templateId?: string;\n  templateOptions?: TemplateOptions;\n};\n\n/** Access key login options to be added to the different authentication methods */\nexport type AccessKeyLoginOptions = {\n  customClaims?: Record<string, any>;\n};\n\n/** Sign Up options to be added to the different authentication methods */\nexport type SignUpOptions = {\n  customClaims?: Record<string, any>;\n  templateId?: string;\n  templateOptions?: TemplateOptions;\n};\n\n/** Authentication info result from the various JWT validations  */\nexport type JWTResponse = {\n  sessionJwt: string;\n  refreshJwt?: string;\n  cookieDomain?: string;\n  cookiePath?: string;\n  cookieMaxAge?: number;\n  cookieExpiration?: number;\n  user?: UserResponse;\n  firstSeen?: boolean;\n  sessionExpiration: number;\n};\n\n/** Authentication info result from exchanging access keys for a session */\nexport type ExchangeAccessKeyResponse = {\n  keyId: string;\n  sessionJwt: string;\n  expiration: number;\n};\n\n/** Options for fine-grained passkey (WebAuthn) control */\nexport type PasskeyOptions = {\n  // attestation only (sign up)\n  authenticatorSelection?: WebauthnAuthenticatorSelectionCriteria;\n  attestation?: 'none' | 'indirect' | 'direct';\n  // assertion only (sign in)\n  userVerification?: 'preferred' | 'required' | 'discouraged';\n  // shared\n  extensionsJSON?: string;\n};\n\n/** Part of the passkey options that apply when performing attestation (sign up) */\nexport type WebauthnAuthenticatorSelectionCriteria = {\n  authenticatorAttachment?: 'any' | 'platform' | 'crossplatform';\n  residentKey?: 'discouraged' | 'preferred' | 'required';\n  userVerification?: 'preferred' | 'required' | 'discouraged';\n};\n\n/** The response returned from the various start webauthn functions */\nexport type WebAuthnStartResponse = {\n  transactionId: string;\n  options: string;\n  create: boolean;\n};\n\n/** Enchanted link response */\nexport type EnchantedLinkResponse = {\n  /** Pending reference URL to poll while waiting for user to click magic link */\n  pendingRef: string;\n  /** Link id, on which link the user should click */\n  linkId: string;\n  /** Email to which the link was sent to */\n  maskedEmail: string;\n};\n\n/** URL response to redirect user in case of OAuth or SSO */\nexport type URLResponse = {\n  url: string;\n};\n\n/** TOTP response with the TOTP details */\nexport type TOTPResponse = {\n  provisioningURL: string;\n  image: string;\n  key: string;\n};\n\n/** Password reset response with details according to response method */\nexport type PasswordResetResponse = {\n  resetMethod: string;\n  pendingRef?: string;\n  linkId?: string;\n  maskedEmail: string;\n};\n\n/** A subset of the password policy that can be checked on the client side for better UX */\nexport type PasswordPolicyResponse = {\n  minLength: number;\n  lowercase: boolean;\n  uppercase: boolean;\n  number: boolean;\n  nonAlphanumeric: boolean;\n};\n\nexport type ClientIdResponse = {\n  clientId: string;\n};\n\nexport type VerifyOneTapIDTokenResponse = {\n  code: string;\n};\n\n/** Phone delivery methods which are currently supported */\nexport enum DeliveryPhone {\n  sms = 'sms',\n  voice = 'voice',\n  whatsapp = 'whatsapp',\n}\n\nexport enum DeliveryEmail {\n  email = 'email',\n}\n\n/** All delivery methods currently supported */\nexport type DeliveryMethods = DeliveryPhone | DeliveryEmail;\n\nexport const DeliveryMethods = {\n  ...DeliveryPhone,\n  ...DeliveryEmail,\n} as const;\n\n/** All flow execution statuses\n *  - waiting - flow execution is waiting for user interaction\n *  - running - flow execution is currently running\n *  - completed - flow execution completed successfully\n *  - failed - flow execution failed\n */\nexport enum FlowStatus {\n  waiting = 'waiting',\n  running = 'running',\n  completed = 'completed',\n  failed = 'failed',\n}\n\n/** All flow response action\n *  - screen - next action is to render  screen\n *  - poll - next action is poll for next after timeout\n *  - redirect - next action is to redirect (redirection details in 'redirect' attribute)\n *  - webauthnCreate/webauthnGet - next action is to prompt webauthn (details in 'webauthn' attribute)\n *  - nativeBridge - the next action needs to be sent via the native bridge to the native layer\n *  - none - no next action\n */\nexport type FlowAction =\n  | 'screen'\n  | 'poll'\n  | 'redirect'\n  | 'webauthnCreate'\n  | 'webauthnGet'\n  | 'nativeBridge'\n  | 'none';\n\nexport type ComponentsConfig = Record<string, any>;\n\n/** Flow response with flow execution details */\nexport type FlowResponse = {\n  // current execution identifier\n  executionId: string;\n  // current step identifier\n  stepId: string;\n  // current step name\n  stepName: string;\n  // flow execution status\n  status: FlowStatus;\n  // the next required action\n  action: FlowAction;\n  // screen data - if action is 'screen'\n  screen?: {\n    // screen identifier\n    id: string;\n    // extra dynamic state required for rendering screen\n    state: Record<string, any>;\n    componentsConfig: ComponentsConfig;\n  };\n  // redirect data - if action is 'redirect'\n  redirect?: {\n    url: string;\n    isPopup?: boolean;\n  };\n  // SAML IDP response (this will be used to build the html form response goes from the IDP through the end user browser to the SP)\n  samlIdpResponse?: {\n    url: string;\n    samlResponse: string;\n    relayState: string;\n  };\n  // a URL to open in a new tab\n  openInNewTabUrl?: string;\n  // webauthn data - if action is one of 'webauthnCreate', 'webauthnGet'\n  webauthn?: {\n    transactionId: string;\n    options: string;\n    create: boolean;\n  };\n  // set if the action is 'nativeBridge'\n  nativeResponse?: {\n    type: 'oauthNative' | 'oauthWeb' | 'webauthnGet' | 'webauthnCreate';\n    payload: Record<string, any>;\n  };\n  // an error that occurred during flow execution, used for debugging / integrating\n  error?: {\n    code: string;\n    description: string;\n    message: string;\n  };\n  // authentication information response, if response is authenticated\n  authInfo?: JWTResponse;\n  lastAuth?: Pick<LastAuth, 'authMethod' | 'oauthProvider'>;\n  runnerLogs?: {\n    title?: string;\n    log: string;\n    level?: 'info' | 'debug' | 'warn' | 'error';\n  }[];\n};\n\nexport type Options = {\n  redirectUrl?: string;\n  location?: string;\n  tenant?: string;\n  deviceInfo?: DeviceInfo;\n  lastAuth?: LastAuth;\n  redirectAuth?: RedirectAuth;\n  oidcIdpStateId?: string;\n  preview?: boolean;\n  samlIdpStateId?: string;\n  samlIdpUsername?: string;\n  ssoAppId?: string;\n  thirdPartyAppId?: string;\n  oidcLoginHint?: string;\n  abTestingKey?: number;\n  startOptionsVersion?: number;\n  client?: Record<string, any>;\n  locale?: string;\n  oidcPrompt?: string;\n  oidcErrorRedirectUri?: string;\n  oidcResource?: string;\n  nativeOptions?: NativeOptions;\n  thirdPartyAppStateId?: string;\n  applicationScopes?: string; // Relevant for sso application and third party application\n  outboundAppId?: string;\n  outboundAppScopes?: string[];\n};\n\nexport type ResponseData = Record<string, any>;\n\n/**\n * Response from our SDK calls which includes the result (ok, code, error).\n * The relevant data is provided in the more specific interfaces extending SdkResponse.\n */\nexport type SdkResponse<T extends ResponseData> = {\n  code?: number;\n  ok: boolean;\n  response?: Response;\n  error?: {\n    errorCode: string;\n    errorDescription: string;\n    errorMessage?: string;\n    retryAfter?: string;\n  };\n  data?: T;\n};\n\n/** Different delivery method */\nexport type Deliveries<T extends Record<DeliveryMethods, SdkFn>> = {\n  [S in DeliveryMethods]: T[S];\n};\n\nexport type DeliveriesPhone<T extends Record<DeliveryPhone, SdkFn> | SdkFn> = {\n  [S in DeliveryPhone]: T extends Record<DeliveryPhone, SdkFn> ? T[S] : T;\n};\n\n/** Map different functions to email vs phone (sms, whatsapp, voice) */\nexport type DeliveriesMap<EmailFn extends SdkFn, PhoneFn extends SdkFn> = {\n  [S in DeliveryMethods]: S extends 'email' ? EmailFn : PhoneFn;\n};\n\n/** Logger type that supports the given levels (debug, log, error) */\nexport type Logger = Pick<Console, 'debug' | 'log' | 'error' | 'warn'>;\n\n/** Polling configuration for session waiting */\nexport type WaitForSessionConfig = {\n  pollingIntervalMs: number;\n  timeoutMs: number;\n};\n\nexport type UpdateOptions<T extends boolean> = {\n  addToLoginIDs?: T;\n  onMergeUseExisting?: T extends true ? boolean : never;\n  templateOptions?: TemplateOptions;\n  templateId?: string;\n  providerId?: string;\n};\n","import {\n  stringNonEmpty,\n  withValidations,\n  stringPhone,\n  stringEmail,\n} from '../validations';\n\nexport const loginIdValidations = stringNonEmpty('loginId');\nexport const withVerifyValidations = withValidations(stringNonEmpty('token'));\nexport const withSignValidations = withValidations(loginIdValidations);\nexport const withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef'),\n);\nexport const withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone'),\n);\nexport const withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email'),\n);\n","import {\n  apiPaths,\n  MAX_POLLING_TIMEOUT_MS,\n  MIN_POLLING_INTERVAL_MS,\n} from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { normalizeWaitForSessionConfig } from '../../utils';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  SdkResponse,\n  JWTResponse,\n  EnchantedLinkResponse,\n  User,\n  LoginOptions,\n  UpdateOptions,\n  SignUpOptions,\n  WaitForSessionConfig,\n} from '../types';\nimport {\n  withWaitForSessionValidations,\n  withSignValidations,\n  withVerifyValidations,\n  withUpdateEmailValidations,\n} from './validations';\n\nconst withEnchantedLink = (httpClient: HttpClient) => ({\n  verify: withVerifyValidations(\n    (token: string): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(apiPaths.enchantedLink.verify, { token }),\n      ),\n  ),\n\n  signIn: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signIn, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            loginOptions,\n          },\n          { token },\n        ),\n      ),\n  ),\n\n  signUpOrIn: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signUpOrIn, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            loginOptions: signUpOptions,\n          },\n        ),\n      ),\n  ),\n\n  signUp: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      user?: User,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signUp, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            user,\n            loginOptions: signUpOptions,\n          },\n        ),\n      ),\n  ),\n\n  waitForSession: withWaitForSessionValidations(\n    (\n      pendingRef: string,\n      config?: WaitForSessionConfig,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      new Promise((resolve) => {\n        const { pollingIntervalMs, timeoutMs } =\n          normalizeWaitForSessionConfig(config);\n        let timeout: NodeJS.Timeout | undefined;\n        const interval = setInterval(async () => {\n          const resp = await httpClient.post(apiPaths.enchantedLink.session, {\n            pendingRef,\n          });\n          if (resp.ok) {\n            clearInterval(interval);\n            if (timeout) clearTimeout(timeout);\n            resolve(transformResponse(Promise.resolve(resp)));\n          }\n        }, pollingIntervalMs);\n\n        timeout = setTimeout(() => {\n          resolve({\n            error: {\n              errorDescription: `Session polling timeout exceeded: ${timeoutMs}ms`,\n              errorCode: '0',\n            },\n            ok: false,\n          });\n          clearInterval(interval);\n        }, timeoutMs);\n      }),\n  ),\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        URI?: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>,\n      ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.enchantedLink.update.email,\n            { loginId, email, URI, ...updateOptions },\n            { token },\n          ),\n        ),\n    ),\n  },\n});\n\nexport default withEnchantedLink;\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport { FlowResponse, Options, SdkResponse } from '../types';\nimport { stringNonEmpty, withValidations } from '../validations';\nimport { FlowInput } from './types';\n\nconst withStartValidations = withValidations(stringNonEmpty('flowId'));\nconst withNextValidations = withValidations(\n  stringNonEmpty('executionId'),\n  stringNonEmpty('stepId'),\n  stringNonEmpty('interactionId'),\n);\n\nconst withFlow = (httpClient: HttpClient) => ({\n  start: withStartValidations(\n    (\n      flowId: string,\n      options?: Options,\n      conditionInteractionId?: string,\n      interactionId?: string,\n      componentsVersion?: string,\n      flowVersions?: Record<string, number>,\n      input?: FlowInput,\n    ): Promise<SdkResponse<FlowResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.flow.start, {\n          flowId,\n          options,\n          conditionInteractionId,\n          interactionId,\n          componentsVersion,\n          flowVersions,\n          input,\n        }),\n      ),\n  ),\n  next: withNextValidations(\n    (\n      executionId: string,\n      stepId: string,\n      interactionId: string,\n      version?: number,\n      componentsVersion?: string,\n      input?: FlowInput,\n    ): Promise<SdkResponse<FlowResponse>> => {\n      return transformResponse(\n        httpClient.post(apiPaths.flow.next, {\n          executionId,\n          stepId,\n          interactionId,\n          version,\n          componentsVersion,\n          input,\n        }),\n      );\n    },\n  ),\n});\n\nexport default withFlow;\n","import {\n  stringNonEmpty,\n  withValidations,\n  stringPhone,\n  stringEmail,\n} from '../validations';\n\nexport const loginIdValidations = stringNonEmpty('loginId');\nexport const withVerifyValidations = withValidations(stringNonEmpty('token'));\nexport const withSignValidations = withValidations(loginIdValidations);\nexport const withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef'),\n);\nexport const withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone'),\n);\nexport const withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email'),\n);\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  DeliveryPhone,\n  SdkResponse,\n  JWTResponse,\n  User,\n  LoginOptions,\n  MaskedEmail,\n  UpdateOptions,\n  SignUpOptions,\n} from '../types';\nimport { MagicLink, Routes } from './types';\nimport {\n  withSignValidations,\n  withVerifyValidations,\n  withUpdateEmailValidations,\n  withUpdatePhoneValidations,\n} from './validations';\n\nconst deliveryMethods = Object.keys(DeliveryMethods).filter(\n  (d) => d !== DeliveryPhone.voice,\n);\n\nconst withMagicLink = (httpClient: HttpClient) => ({\n  verify: withVerifyValidations(\n    (token: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.magicLink.verify, { token })),\n  ),\n\n  signIn: deliveryMethods.reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (\n          loginId: string,\n          URI?: string,\n          loginOptions?: LoginOptions,\n          token?: string,\n        ) =>\n          transformResponse(\n            httpClient.post(\n              pathJoin(apiPaths.magicLink.signIn, delivery),\n              { loginId, URI, loginOptions },\n              { token },\n            ),\n          ),\n      ),\n    }),\n    {},\n  ) as MagicLink[Routes.signIn],\n\n  signUp: deliveryMethods.reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (\n          loginId: string,\n          URI?: string,\n          user?: User,\n          signUpOptions?: SignUpOptions,\n        ) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.magicLink.signUp, delivery), {\n              loginId,\n              URI,\n              user,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as MagicLink[Routes.signUp],\n\n  signUpOrIn: deliveryMethods.reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, URI?: string, signUpOptions?: SignUpOptions) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.magicLink.signUpOrIn, delivery), {\n              loginId,\n              URI,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as MagicLink[Routes.signUpOrIn],\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        URI?: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>,\n      ): Promise<SdkResponse<MaskedEmail>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.magicLink.update.email,\n            { loginId, email, URI, ...updateOptions },\n            { token },\n          ),\n        ),\n    ),\n    phone: Object.keys(DeliveryPhone)\n      .filter((d) => d !== DeliveryPhone.voice)\n      .reduce(\n        (acc, delivery) => ({\n          ...acc,\n          [delivery]: withUpdatePhoneValidations(\n            <T extends boolean>(\n              loginId: string,\n              phone: string,\n              URI?: string,\n              token?: string,\n              updateOptions?: UpdateOptions<T>,\n            ) =>\n              transformResponse(\n                httpClient.post(\n                  pathJoin(apiPaths.magicLink.update.phone, delivery),\n                  { loginId, phone, URI, ...updateOptions },\n                  { token },\n                ),\n              ),\n          ),\n        }),\n        {},\n      ) as MagicLink[Routes.updatePhone],\n  },\n});\n\nexport default withMagicLink;\n","import { SdkResponse, URLResponse, JWTResponse, LoginOptions } from '../types';\n\nenum OAuthProviders {\n  facebook = 'facebook',\n  github = 'github',\n  google = 'google',\n  microsoft = 'microsoft',\n  gitlab = 'gitlab',\n  apple = 'apple',\n  discord = 'discord',\n  linkedin = 'linkedin',\n  slack = 'slack',\n}\n\ntype VerifyFn = (code: string) => Promise<SdkResponse<JWTResponse>>;\nexport type StartFn = (\n  redirectURL?: string,\n  loginOptions?: LoginOptions,\n  token?: string,\n) => Promise<SdkResponse<URLResponse>>;\n\nexport type Providers<T> = Record<keyof typeof OAuthProviders, T>;\n\nexport type Oauth = {\n  start: Providers<StartFn>;\n  verify: Providers<VerifyFn>;\n};\n\nexport { OAuthProviders };\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport {\n  SdkResponse,\n  JWTResponse,\n  LoginOptions,\n  ClientIdResponse,\n  VerifyOneTapIDTokenResponse,\n} from '../types';\nimport { transformResponse } from '../helpers';\nimport { Oauth, OAuthProviders } from './types';\nimport { stringNonEmpty, withValidations } from '../validations';\n\nconst withExchangeValidations = withValidations(stringNonEmpty('code'));\nconst withOauth = (httpClient: HttpClient) => ({\n  start: Object.assign(\n    (\n      provider: string,\n      redirectUrl?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n      loginHint?: string,\n    ) => {\n      return transformResponse(\n        httpClient.post(apiPaths.oauth.start, loginOptions || {}, {\n          queryParams: {\n            provider,\n            ...(redirectUrl && { redirectURL: redirectUrl }),\n            ...(loginHint && { loginHint }),\n          },\n          token,\n        }),\n      );\n    },\n    Object.keys(OAuthProviders).reduce(\n      (acc, provider) => ({\n        ...acc,\n        [provider]: (\n          redirectUrl?: string,\n          loginOptions?: LoginOptions,\n          token?: string,\n          loginHint?: string,\n        ) =>\n          transformResponse(\n            httpClient.post(apiPaths.oauth.start, loginOptions || {}, {\n              queryParams: {\n                provider,\n                ...(redirectUrl && { redirectURL: redirectUrl }),\n                ...(loginHint && { loginHint }),\n              },\n              token,\n            }),\n          ),\n      }),\n      {},\n    ) as Oauth['start'],\n  ),\n  exchange: withExchangeValidations(\n    (code: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.oauth.exchange, { code })),\n  ),\n  startNative: (\n    provider: string,\n    loginOptions?: LoginOptions,\n    implicit?: boolean,\n  ) =>\n    transformResponse(\n      httpClient.post(apiPaths.oauth.startNative, {\n        provider,\n        loginOptions,\n        implicit,\n      }),\n    ),\n  finishNative: (\n    provider: string,\n    stateId: string,\n    user?: string,\n    code?: string,\n    idToken?: string,\n  ) =>\n    transformResponse(\n      httpClient.post(apiPaths.oauth.finishNative, {\n        provider,\n        stateId,\n        user,\n        code,\n        idToken,\n      }),\n    ),\n  getOneTapClientId: (provider: string) =>\n    transformResponse<ClientIdResponse>(\n      httpClient.get(\n        apiPaths.oauth.oneTap.getOneTapClientId.replace('{provider}', provider),\n      ),\n    ),\n  verifyOneTapIDToken: (\n    provider: string,\n    idToken: string,\n    nonce: string,\n    loginOptions?: LoginOptions,\n  ) =>\n    transformResponse<VerifyOneTapIDTokenResponse>(\n      httpClient.post(apiPaths.oauth.oneTap.verifyOneTapIDToken, {\n        provider,\n        idToken,\n        nonce,\n        loginOptions,\n      }),\n    ),\n  exchangeOneTapIDToken: (\n    provider: string,\n    idToken: string,\n    nonce: string,\n    loginOptions?: LoginOptions,\n  ) =>\n    transformResponse<JWTResponse>(\n      httpClient.post(apiPaths.oauth.oneTap.exchangeOneTapIDToken, {\n        provider,\n        idToken,\n        nonce,\n        loginOptions,\n      }),\n    ),\n});\n\nexport default withOauth;\n","import {\n  isStringOrUndefinedValidator,\n  stringNonEmpty,\n  withValidations,\n} from '../validations';\n\nconst appIdValidation = stringNonEmpty('appId');\nexport const withConnectValidations = withValidations(appIdValidation);\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport { ConnectOptions } from './types';\nimport { SdkResponse, URLResponse } from '../types';\nimport { withConnectValidations } from './validations';\n\nconst withOutbound = (httpClient: HttpClient) => ({\n  connect: withConnectValidations(\n    (\n      appId: string,\n      options?: ConnectOptions,\n      token?: string,\n    ): Promise<SdkResponse<URLResponse>> => {\n      const tenantId = options?.tenantId;\n      const tenantLevel = options?.tenantLevel;\n      delete options?.tenantId;\n      delete options?.tenantLevel;\n      return transformResponse(\n        httpClient.post(\n          apiPaths.outbound.connect,\n          {\n            appId,\n            tenantId,\n            tenantLevel,\n            options,\n          },\n          {\n            token,\n          },\n        ),\n      );\n    },\n  ),\n});\n\nexport default withOutbound;\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  User,\n  SdkResponse,\n  JWTResponse,\n  DeliveryPhone,\n  LoginOptions,\n  MaskedEmail,\n  UpdateOptions,\n  SignUpOptions,\n} from '../types';\nimport {\n  stringEmail,\n  stringNonEmpty,\n  stringPhone,\n  withValidations,\n} from '../validations';\nimport { Otp, Routes } from './types';\n\nconst loginIdValidations = stringNonEmpty('loginId');\nconst withVerifyValidations = withValidations(\n  loginIdValidations,\n  stringNonEmpty('code'),\n);\nconst withSignValidations = withValidations(loginIdValidations);\nconst withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone'),\n);\nconst withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email'),\n);\n\nconst withOtp = (httpClient: HttpClient) => ({\n  verify: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withVerifyValidations(\n        (loginId: string, code: string): Promise<SdkResponse<JWTResponse>> =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.verify, delivery), {\n              code,\n              loginId,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.verify],\n\n  signIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, loginOptions?: LoginOptions, token?: string) =>\n          transformResponse(\n            httpClient.post(\n              pathJoin(apiPaths.otp.signIn, delivery),\n              { loginId, loginOptions },\n              { token },\n            ),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.signIn],\n\n  signUp: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, user?: User, signUpOptions?: SignUpOptions) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.signUp, delivery), {\n              loginId,\n              user,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.signUp],\n\n  signUpOrIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, signUpOptions?: SignUpOptions) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.signUpOrIn, delivery), {\n              loginId,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.signIn],\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>,\n      ): Promise<SdkResponse<MaskedEmail>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.otp.update.email,\n            { loginId, email, ...updateOptions },\n            { token },\n          ),\n        ),\n    ),\n    phone: Object.keys(DeliveryPhone).reduce(\n      (acc, delivery) => ({\n        ...acc,\n        [delivery]: withUpdatePhoneValidations(\n          <T extends boolean>(\n            loginId: string,\n            phone: string,\n            token?: string,\n            updateOptions?: UpdateOptions<T>,\n          ) =>\n            transformResponse(\n              httpClient.post(\n                pathJoin(apiPaths.otp.update.phone, delivery),\n                { loginId, phone, ...updateOptions },\n                { token },\n              ),\n            ),\n        ),\n      }),\n      {},\n    ) as Otp[Routes.updatePhone],\n  },\n});\n\nexport default withOtp;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport { SdkResponse, URLResponse, JWTResponse, LoginOptions } from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst withStartValidations = withValidations(stringNonEmpty('tenant'));\nconst withExchangeValidations = withValidations(stringNonEmpty('code'));\n\nconst withSaml = (httpClient: HttpClient) => ({\n  start: withStartValidations(\n    (\n      tenantIdOrEmail: string,\n      redirectUrl?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n      ssoId?: string,\n      forceAuthn?: boolean,\n      loginHint?: string,\n    ): Promise<SdkResponse<URLResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.saml.start, loginOptions || {}, {\n          queryParams: {\n            tenant: tenantIdOrEmail,\n            ...(redirectUrl && { redirectURL: redirectUrl }),\n            ...(ssoId && { ssoId }),\n            ...(forceAuthn && { forceAuthn: 'true' }),\n            ...(loginHint && { loginHint }),\n          },\n          ...(token && { token }),\n        }),\n      ),\n  ),\n  exchange: withExchangeValidations(\n    (code: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.saml.exchange, { code })),\n  ),\n});\n\nexport default withSaml;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  User,\n  SdkResponse,\n  JWTResponse,\n  TOTPResponse,\n  LoginOptions,\n} from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst loginIdValidations = stringNonEmpty('loginId');\nconst withVerifyValidations = withValidations(\n  loginIdValidations,\n  stringNonEmpty('code'),\n);\nconst withSignUpValidations = withValidations(loginIdValidations);\nconst withUpdateValidations = withValidations(loginIdValidations);\n\nconst withTotp = (httpClient: HttpClient) => ({\n  signUp: withSignUpValidations(\n    (loginId: string, user?: User): Promise<SdkResponse<TOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.totp.signUp, { loginId, user }),\n      ),\n  ),\n\n  verify: withVerifyValidations(\n    (\n      loginId: string,\n      code: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.totp.verify,\n          { loginId, code, loginOptions },\n          { token },\n        ),\n      ),\n  ),\n\n  update: withUpdateValidations(\n    (loginId: string, token?: string): Promise<SdkResponse<TOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.totp.update, { loginId }, { token }),\n      ),\n  ),\n});\n\nexport default withTotp;\n","import { stringNonEmpty, withValidations } from '../validations';\n\nconst loginIdValidation = stringNonEmpty('loginId');\nconst newPasswordValidation = stringNonEmpty('newPassword');\nexport const withSignValidations = withValidations(\n  loginIdValidation,\n  stringNonEmpty('password'),\n);\nexport const withSendResetValidations = withValidations(loginIdValidation);\nexport const withUpdateValidation = withValidations(\n  loginIdValidation,\n  newPasswordValidation,\n);\nexport const withReplaceValidation = withValidations(\n  loginIdValidation,\n  stringNonEmpty('oldPassword'),\n  newPasswordValidation,\n);\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport {\n  JWTResponse,\n  LoginOptions,\n  PasswordPolicyResponse,\n  PasswordResetResponse,\n  SdkResponse,\n  SignUpOptions,\n  TemplateOptions,\n  User,\n} from '../types';\nimport {\n  withReplaceValidation,\n  withSendResetValidations,\n  withSignValidations,\n  withUpdateValidation,\n} from './validations';\n\nconst withPassword = (httpClient: HttpClient) => ({\n  signUp: withSignValidations(\n    (\n      loginId: string,\n      password: string,\n      user?: User,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.signUp, {\n          loginId,\n          password,\n          user,\n          loginOptions: signUpOptions,\n        }),\n      ),\n  ),\n\n  signIn: withSignValidations(\n    (\n      loginId: string,\n      password: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.signIn, {\n          loginId,\n          password,\n          loginOptions,\n        }),\n      ),\n  ),\n\n  sendReset: withSendResetValidations(\n    (\n      loginId: string,\n      redirectUrl?: string,\n      templateOptions?: TemplateOptions,\n    ): Promise<SdkResponse<PasswordResetResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.sendReset, {\n          loginId,\n          redirectUrl,\n          templateOptions,\n        }),\n      ),\n  ),\n\n  update: withUpdateValidation(\n    (\n      loginId: string,\n      newPassword: string,\n      token?: string,\n    ): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.password.update,\n          {\n            loginId,\n            newPassword,\n          },\n          { token },\n        ),\n      ),\n  ),\n\n  replace: withReplaceValidation(\n    (\n      loginId: string,\n      oldPassword: string,\n      newPassword: string,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.replace, {\n          loginId,\n          oldPassword,\n          newPassword,\n        }),\n      ),\n  ),\n\n  policy: (): Promise<SdkResponse<PasswordPolicyResponse>> =>\n    transformResponse(httpClient.get(apiPaths.password.policy)),\n});\n\nexport default withPassword;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  SdkResponse,\n  ResponseData,\n  LoginOptions,\n  JWTResponse,\n  PasskeyOptions,\n  WebAuthnStartResponse,\n} from './types';\nimport {\n  isStringOrUndefinedValidator,\n  string,\n  stringNonEmpty,\n  withValidations,\n} from './validations';\n\nconst loginIdStringValidations = string('loginId');\nconst loginIdNonEmptyValidations = stringNonEmpty('loginId');\nconst originValidations = stringNonEmpty('origin');\n\nconst withSignUpStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n  stringNonEmpty('name'),\n);\nconst withSignUpOrInStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n);\nconst withSignInStartValidations = withValidations(\n  loginIdStringValidations,\n  originValidations,\n);\nconst withUpdateStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n  isStringOrUndefinedValidator('token'),\n);\nconst withFinishValidations = withValidations(\n  stringNonEmpty('transactionId'),\n  stringNonEmpty('response'),\n);\n\nconst withWebauthn = (httpClient: HttpClient) => ({\n  signUp: {\n    start: withSignUpStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        name: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUp.start, {\n            user: {\n              loginId,\n              name,\n            },\n            origin,\n            passkeyOptions,\n          }),\n        ),\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string,\n      ): Promise<SdkResponse<JWTResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUp.finish, {\n            transactionId,\n            response,\n          }),\n        ),\n    ),\n  },\n\n  signIn: {\n    start: withSignInStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        loginOptions?: LoginOptions,\n        token?: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.webauthn.signIn.start,\n            { loginId, origin, loginOptions, passkeyOptions },\n            { token },\n          ),\n        ),\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string,\n      ): Promise<SdkResponse<JWTResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signIn.finish, {\n            transactionId,\n            response,\n          }),\n        ),\n    ),\n  },\n\n  signUpOrIn: {\n    start: withSignUpOrInStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUpOrIn.start, {\n            loginId,\n            origin,\n            passkeyOptions,\n          }),\n        ),\n    ),\n  },\n\n  update: {\n    start: withUpdateStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        token?: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.webauthn.update.start,\n            { loginId, origin, passkeyOptions },\n            { token },\n          ),\n        ),\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string,\n      ): Promise<SdkResponse<ResponseData>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.update.finish, {\n            transactionId,\n            response,\n          }),\n        ),\n    ),\n  },\n});\n\nexport default withWebauthn;\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { normalizeWaitForSessionConfig } from '../../utils';\nimport { transformResponse } from '../helpers';\nimport {\n  JWTResponse,\n  LoginOptions,\n  SdkResponse,\n  SignUpOptions,\n  User,\n  WaitForSessionConfig,\n} from '../types';\nimport { stringNonEmpty, string, withValidations } from '../validations';\nimport { NOTPResponse } from './types';\n\nconst loginIdValidations = string('loginId');\n\nconst withSignValidations = withValidations(loginIdValidations);\n\nconst withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef'),\n);\n\nconst withNotp = (httpClient: HttpClient) => ({\n  signUpOrIn: withSignValidations(\n    (\n      loginId?: string,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<NOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.notp.signUpOrIn, {\n          loginId,\n          loginOptions: signUpOptions,\n        }),\n      ),\n  ),\n  signUp: withSignValidations(\n    (\n      loginId?: string,\n      user?: User,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<NOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.notp.signUp, {\n          loginId,\n          user,\n          loginOptions: signUpOptions,\n        }),\n      ),\n  ),\n  signIn: withSignValidations(\n    (\n      loginId?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n    ): Promise<SdkResponse<NOTPResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.notp.signIn,\n          { loginId, loginOptions },\n          { token },\n        ),\n      ),\n  ),\n  waitForSession: withWaitForSessionValidations(\n    (\n      pendingRef: string,\n      config?: WaitForSessionConfig,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      new Promise((resolve) => {\n        const { pollingIntervalMs, timeoutMs } =\n          normalizeWaitForSessionConfig(config);\n        let timeout: NodeJS.Timeout | undefined;\n        const interval = setInterval(async () => {\n          const resp = await httpClient.post(apiPaths.notp.session, {\n            pendingRef,\n          });\n          if (resp.ok) {\n            clearInterval(interval);\n            if (timeout) clearTimeout(timeout);\n            resolve(transformResponse(Promise.resolve(resp)));\n          }\n        }, pollingIntervalMs);\n\n        timeout = setTimeout(() => {\n          resolve({\n            error: {\n              errorDescription: `Session polling timeout exceeded: ${timeoutMs}ms`,\n              errorCode: '0',\n            },\n            ok: false,\n          });\n          clearInterval(interval);\n        }, timeoutMs);\n      }),\n  ),\n});\n\nexport default withNotp;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport withAccessKeys from './accesskey';\nimport withEnchantedLink from './enchantedLink';\nimport withFlow from './flow';\nimport {\n  getTenants,\n  getJwtPermissions,\n  getJwtRoles,\n  getCurrentTenant,\n  isJwtExpired,\n  transformResponse,\n} from './helpers';\nimport withMagicLink from './magicLink';\nimport withOauth from './oauth';\nimport withOutbound from './outbound';\nimport withOtp from './otp';\nimport withSaml from './saml';\nimport withTotp from './totp';\nimport withPassword from './password';\nimport {\n  JWTResponse,\n  TenantsResponse,\n  UserHistoryResponse,\n  UserResponse,\n} from './types';\nimport {\n  stringNonEmpty,\n  withValidations,\n  isStringOrUndefinedValidator,\n} from './validations';\nimport withWebauthn from './webauthn';\nimport {\n  isArrayOrBool,\n  isString,\n  isStringOrUndefined,\n} from './validations/validators';\nimport withNotp from './notp';\n\nconst withJwtValidations = withValidations(stringNonEmpty('token'));\nconst withOptionalTokenValidations = withValidations(\n  isStringOrUndefinedValidator('token'),\n);\n\n/** Returns Descope SDK with all available operations */\nexport default (httpClient: HttpClient) => ({\n  accessKey: withAccessKeys(httpClient),\n  otp: withOtp(httpClient),\n  magicLink: withMagicLink(httpClient),\n  enchantedLink: withEnchantedLink(httpClient),\n  oauth: withOauth(httpClient),\n  outbound: withOutbound(httpClient),\n  saml: withSaml(httpClient),\n  totp: withTotp(httpClient),\n  notp: withNotp(httpClient),\n  webauthn: withWebauthn(httpClient),\n  password: withPassword(httpClient),\n  flow: withFlow(httpClient),\n  /**\n   * Refreshes a session token\n   * Should be called when a session has expired (failed validation) to renew it\n   * @param token A valid refresh token\n   * @param queryParams Additional query parameters to send with the request.\n   * @param externalToken An external token to exchange for a new session token\n   * @param tryRefresh If true, will use the tryRefresh endpoint, which will not fail if token is missing, invalid or expired.\n   *    NOTE - queryParams is used internally and should NOT be used by other consumers, this is subject to change and may be removed in the near future.\n   * @returns The updated authentication info (JWTs)\n   */\n  refresh: withOptionalTokenValidations(\n    (\n      token?: string,\n      queryParams?: { [key: string]: string },\n      externalToken?: string,\n      tryRefresh?: boolean,\n    ) => {\n      const body = {};\n      if (externalToken) {\n        body['externalToken'] = externalToken;\n      }\n      const path = tryRefresh ? apiPaths.tryRefresh : apiPaths.refresh;\n      return transformResponse<JWTResponse>(\n        httpClient.post(path, body, { token, queryParams }),\n      );\n    },\n  ),\n  /**\n   * Selects a tenant for the current session\n   * @param tenantId The tenant to select\n   * @param token A valid refresh token\n   * @returns The updated authentication info (JWTs). The session token will be updated with the selected tenant under the \"dct\" claim\n   */\n  selectTenant: withValidations(\n    [isString('tenantId')],\n    [isStringOrUndefined('\"token\" must be string or undefined')],\n  )((tenantId: string, token?: string) =>\n    transformResponse<JWTResponse>(\n      httpClient.post(apiPaths.selectTenant, { tenant: tenantId }, { token }),\n    ),\n  ),\n  /**\n   * Logs out the current session\n   * @param token A valid refresh token\n   */\n  logout: withOptionalTokenValidations((token?: string) =>\n    transformResponse<never>(httpClient.post(apiPaths.logout, {}, { token })),\n  ),\n  /**\n   * Logs out all sessions for the current user\n   * @param token A valid refresh token\n   */\n  logoutAll: withOptionalTokenValidations((token?: string) =>\n    transformResponse<never>(\n      httpClient.post(apiPaths.logoutAll, {}, { token }),\n    ),\n  ),\n  /**\n   * Returns the current user details\n   * @param token A valid refresh token\n   * @returns The current user details\n   */\n  me: withOptionalTokenValidations((token?: string) =>\n    transformResponse<UserResponse>(httpClient.get(apiPaths.me, { token })),\n  ),\n  /**\n   * Returns the current user details\n   * @param tenants set to true IFF the response should include only the selected tenant from JWT, or list of tenant ids\n   * @param token A valid refresh token\n   * @returns The current user details\n   */\n  myTenants: withValidations(\n    [isArrayOrBool('\"tenants\" must a string array or a boolean')],\n    [isStringOrUndefined('\"token\" must be string or undefined')],\n  )((tenants: true | string[], token?: string) => {\n    const body = {};\n    if (typeof tenants === 'boolean') {\n      body['dct'] = tenants;\n    } else {\n      body['ids'] = tenants;\n    }\n    return transformResponse<TenantsResponse>(\n      httpClient.post(apiPaths.myTenants, body, { token }),\n    );\n  }),\n  /**\n   * Returns the current user authentication history\n   * @param token A valid refresh token\n   * @returns The current user authentication history\n   */\n  history: withOptionalTokenValidations((token?: string) =>\n    transformResponse<UserHistoryResponse>(\n      httpClient.get(apiPaths.history, { token }),\n    ),\n  ),\n  /**\n   * Checks if the given JWT is still valid but DOES NOT check for signature\n   * @param token A valid token\n   * @returns true if the JWT is expired, false otherwise\n   */\n  isJwtExpired: withJwtValidations(isJwtExpired),\n  /**\n   * Returns the list of tenants in the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @returns The list of tenants in the given JWT\n   */\n  getTenants: withJwtValidations(getTenants),\n  /**\n   * Returns the list of permissions granted in the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @param tenant The tenant to check permissions for. If not provided, the permissions for the current tenant will be returned\n   * @returns The list of permissions granted in the given JWT\n   */\n  getJwtPermissions: withJwtValidations(getJwtPermissions),\n  /**\n   * Returns the list of roles specified in the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @param tenant The tenant to check roles for. If not provided, the roles for the current tenant will be returned\n   * @returns The list of roles specified in the given JWT\n   */\n  getJwtRoles: withJwtValidations(getJwtRoles),\n  /**\n   * Returns Descope current tenant from the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @returns The current tenant from the given JWT\n   */\n  getCurrentTenant: withJwtValidations(getCurrentTenant),\n  /**\n   * Parses the given JWT token but DOES NOT check for signature\n   * @param token A valid token\n   * @returns The parsed JWT token\n   */\n  httpClient,\n});\n","import createHttpClient from './httpClient';\nimport { Fetch, MultipleHooks } from './httpClient/types';\nimport createSdk from './sdk';\nimport { Logger } from './sdk/types';\nimport { stringNonEmpty, withValidations } from './sdk/validations';\nimport { hasPathValue } from './sdk/validations/validators';\n\ntype SdkConfig = {\n  projectId: string;\n  logger?: Logger;\n  baseUrl?: string;\n  hooks?: MultipleHooks;\n  cookiePolicy?: RequestCredentials | null;\n  baseHeaders?: HeadersInit;\n  refreshCookieName?: string;\n  fetch?: Fetch;\n};\n\n/** Validate we have non-empty project id */\nconst withSdkConfigValidations = withValidations([\n  hasPathValue('projectId', stringNonEmpty('projectId')),\n]);\n\n/** Descope SDK client */\nexport default withSdkConfigValidations((config: SdkConfig) => {\n  const {\n    projectId,\n    logger,\n    baseUrl,\n    cookiePolicy,\n    baseHeaders = {},\n    refreshCookieName,\n    fetch,\n  } = config;\n\n  return createSdk(\n    createHttpClient({\n      baseUrl,\n      projectId,\n      logger,\n      hooks: {\n        get beforeRequest() {\n          return config.hooks?.beforeRequest;\n        },\n        get afterRequest() {\n          return config.hooks?.afterRequest;\n        },\n        get transformResponse() {\n          return config.hooks?.transformResponse;\n        },\n      },\n      cookiePolicy,\n      baseConfig: { baseHeaders },\n      refreshCookieName,\n      fetch,\n    }),\n  );\n});\n","import createSdk from './createSdk';\nimport {\n  CreateHttpClientConfig,\n  ExtendedResponse,\n  HttpClient,\n  HTTPMethods,\n  RequestConfig,\n} from './httpClient/types';\nimport { OAuthProviders } from './sdk/oauth/types';\nimport { DeliveryMethods } from './sdk/types';\n\n/** Descope SDK client with delivery methods enum.\n *\n * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}\n * @example Usage\n *\n * ```js\n * import descopeSdk from '@descope/core-js-sdk';\n *\n * const myProjectId = 'xxx';\n * const sdk = descopeSdk({ projectId: myProjectId });\n *\n * const userLoginId = 'loginId';\n * sdk.otp.signIn.email(userLoginId);\n * const jwtResponse = sdk.otp.verify.email(userIdentifier, codeFromEmail);\n * ```\n */\nexport default Object.assign(createSdk, { DeliveryMethods });\n\nexport { default as HttpStatusCodes } from './constants/httpStatusCodes';\nexport { default as createHttpClient } from './httpClient';\nexport { transformResponse } from './sdk/helpers';\nexport type {\n  AccessKeyLoginOptions,\n  EnchantedLinkResponse,\n  ExchangeAccessKeyResponse,\n  FlowAction,\n  FlowResponse,\n  FlowStatus,\n  JWTResponse,\n  LoginOptions,\n  PasskeyOptions,\n  ResponseData,\n  SdkResponse,\n  TOTPResponse,\n  URLResponse,\n  UserHistoryResponse,\n  UserResponse,\n} from './sdk/types';\nexport * from './utils';\nexport type { SdkFnWrapper } from './utils';\nexport type {\n  CreateHttpClientConfig,\n  ExtendedResponse,\n  HttpClient,\n  HTTPMethods,\n  RequestConfig,\n};\n\n/** Type to restrict to valid delivery methods */\nexport type DeliveryMethod = keyof typeof DeliveryMethods;\n/** Type to restrict to valid OAuth providers */\nexport type OAuthProvider = keyof typeof OAuthProviders;\n","/* eslint-disable import/exports-last */\nimport { ResponseData } from '../../sdk/types';\nimport { SdkFnWrapper, ReplacePaths, SdkFnsPaths } from './types';\n\n/**\n * A wrapper function that allows to wrap multiple Sdk function\n * @param obj: The Sdk instance you want to wrap\n * @param paths: A readonly list of paths of the functions you want to wrap\n * @param wrapper: Your wrapper function, it should gets an Sdk function and return a new Sdk function\n * @returns a mutated instance of the Sdk with updated type definitions based on your wrapper return type\n *\n * Usage example:\n *\n * // Assuming this is our SDK instance\n * const sdk = {\n *    me: (token) => {...}\n *    flow: {\n *       start: (...params) => {...}\n *       next: (...params) => {...}\n *    }\n *    ...\n * }\n *\n * // This is our wrapper\n * const wrapper = (sdkFn) => async (...args) => {\n *    const sdkResponse = await sdkFn(...args)\n *\n *    // Modify return value\n *    return {...sdkResponse, data: {...sdkResponse.data, myCustomAttribute: 'hello'}}\n * }\n *\n * // And those are the paths we want to wrap\n * const paths = ['flow.start', 'flow.next'] as const // You MUST add as const!\n *\n * // We can wrap our SDK functions with the wrapper we created in this way\n * const newlyTypedSdk = wrapWith(sdk, paths, wrapper)\n *\n * Now the 2 wrapped functions will have the updated type based on the wrapper return value\n */\n\nconst wrapWith = <\n  Obj extends object,\n  Paths extends ReadonlyArray<SdkFnsPaths<Obj>>,\n  WrapperData extends ResponseData,\n>(\n  obj: Obj,\n  paths: Paths,\n  wrapper: SdkFnWrapper<WrapperData>,\n): ReplacePaths<Obj, Paths, WrapperData> => {\n  paths.forEach((path) => {\n    const sections = path.split('.');\n    let section = sections.shift();\n    let currentRef: Record<string, any> = obj;\n\n    while (sections.length > 0) {\n      currentRef = currentRef[section];\n\n      if (!section || !currentRef) {\n        throw Error(\n          `Invalid path \"${path}\", \"${section}\" is missing or has no value`,\n        );\n      }\n\n      section = sections.shift();\n    }\n\n    if (typeof currentRef[section] !== 'function') {\n      throw Error(`\"${path}\" is not a function`);\n    }\n    const origFn = currentRef[section];\n    currentRef[section] = wrapper(origFn);\n  });\n\n  return obj as any;\n};\n\nexport default wrapWith;\n"],"names":["apiPaths","accessKey","exchange","otp","verify","signIn","signUp","update","email","phone","signUpOrIn","magicLink","enchantedLink","session","oauth","start","startNative","finishNative","oneTap","getOneTapClientId","exchangeOneTapIDToken","verifyOneTapIDToken","outbound","connect","saml","totp","notp","webauthn","finish","password","sendReset","replace","policy","refresh","tryRefresh","selectTenant","logout","logoutAll","me","myTenants","history","flow","next","BASE_URL_REGION_PLACEHOLDER","DEFAULT_BASE_API_URL","MIN_POLLING_INTERVAL_MS","MAX_POLLING_TIMEOUT_MS","DESCOPE_CURRENT_TENANT_CLAIM","httpLogBuilder","msg","headers","headersObj","entries","Object","fromEntries","Headers","JSON","stringify","this","body","Body","url","Url","toString","method","Method","title","Title","status","Status","retries","Retries","build","keys","flatMap","key","join","retryStatusCodes","fetchWrapper","fetch","async","args","resp","includes","respText","text","Promise","resolve","json","parse","clone","createFetchLogger","logger","receivedFetch","baseFetch","warn","Error","log","buildRequestLog","ok","respBody","statusText","buildResponseLog","sessionId","getClientSessionId","currentDate","Date","utcString","getUTCFullYear","getUTCMonth","padStart","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","randomSuffix","Math","floor","random","HTTPMethods","urlBuilder","path","baseUrl","queryParams","projectId","region","slice","forEach","index","encodeURIComponent","length","mergeHeaders","sources","reduce","acc","source","Array","isArray","from","getSrcArr","value","jsonHeaders","createAuthorizationHeader","token","bearer","Authorization","createDescopeHeaders","refreshCookieName","res","isJson","e","createHttpClient$1","createHttpClient","config","assign","hooks","beforeRequest","conf","beforeRequestHooks","concat","_a","fn","afterRequest","req","afterRequestHooks","allSettled","map","result","error","reason","transformResponse","withMultipleHooks","recBaseUrl","baseConfig","cookiePolicy","fetchWithLogger","sendRequest","requestConfig","serializedBody","undefined","serializeBody","requestInit","baseHeaders","credentials","cookies","get","split","cookie","trim","mutableResponse","post","patch","put","delete","buildUrl","HttpStatusCodes","TOO_MANY_REQUESTS","getJwtAuthorizationItems","tenant","claim","claims","parseJwt","tenants","items","jwtDecode","isJwtExpired","exp","getTime","getTenants","getJwtPermissions","getJwtRoles","pathJoin","response","transform","ret","code","data","retryAfter","Number","parseInt","getCurrentTenant","createValidator","rule","defaultMsg","val","createOrValidator","validators","errors","filter","validator","createValidation","validate","errMsg","regexMatch","regex","test","validateEmail","validatePhone","validatePathValue","rules","object","pathName","defaultValue","parts","String","m","i","v","isEmail","isPhone","isNotEmpty","min","isString","isBoolean","isUndefined","isStringOrUndefined","isArrayOrBool","withValidations","argsRules","rulesArr","string","fieldName","isStringOrUndefinedValidator","stringNonEmpty","stringEmail","stringPhone","withExchangeValidations","withAccessKeys","httpClient","loginOptions","normalizeWaitForSessionConfig","pollingIntervalMs","timeoutMs","max","DeliveryPhone","DeliveryEmail","DeliveryMethods","FlowStatus","loginIdValidations","withVerifyValidations","withSignValidations","withWaitForSessionValidations","withUpdateEmailValidations","withEnchantedLink","loginId","URI","signUpOptions","user","waitForSession","pendingRef","timeout","interval","setInterval","clearInterval","clearTimeout","setTimeout","errorDescription","errorCode","updateOptions","withStartValidations","withNextValidations","withFlow","flowId","options","conditionInteractionId","interactionId","componentsVersion","flowVersions","input","executionId","stepId","version","withUpdatePhoneValidations","deliveryMethods","d","voice","withMagicLink","delivery","OAuthProviders","withOauth","provider","redirectUrl","loginHint","redirectURL","implicit","stateId","idToken","nonce","appIdValidation","withConnectValidations","withOutbound","appId","tenantId","tenantLevel","withOtp","withSaml","tenantIdOrEmail","ssoId","forceAuthn","withSignUpValidations","withUpdateValidations","withTotp","loginIdValidation","newPasswordValidation","withSendResetValidations","withUpdateValidation","withReplaceValidation","withPassword","templateOptions","newPassword","oldPassword","loginIdStringValidations","loginIdNonEmptyValidations","originValidations","withSignUpStartValidations","withSignUpOrInStartValidations","withSignInStartValidations","withUpdateStartValidations","withFinishValidations","withWebauthn","origin","name","passkeyOptions","transactionId","withNotp","withJwtValidations","withOptionalTokenValidations","createSdk","withSdkConfigValidations","externalToken","obj","paths","wrapper","sections","section","shift","currentRef","origFn"],"mappings":"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"}