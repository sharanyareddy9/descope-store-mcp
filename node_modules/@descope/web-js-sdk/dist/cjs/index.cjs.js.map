{"version":3,"file":"index.cjs.js","sources":["../../src/enhancers/helpers/index.ts","../../src/enhancers/helpers/logger.ts","../../src/constants.ts","../../src/enhancers/withAutoRefresh/helpers.ts","../../src/enhancers/withPersistTokens/constants.ts","../../src/enhancers/withPersistTokens/helpers.ts","../../src/enhancers/withFingerprint/constants.ts","../../src/enhancers/withFingerprint/helpers.ts","../../src/enhancers/withFingerprint/index.ts","../../src/enhancers/withFlowNonce/constants.ts","../../src/enhancers/withFlowNonce/helpers.ts","../../src/enhancers/withLastLoggedInUser/constants.ts","../../src/enhancers/withLastLoggedInUser/helpers.ts","../../src/enhancers/withLastLoggedInUser/index.ts","../../src/enhancers/withNotifications/helpers.ts","../../src/enhancers/withNotifications/index.ts","../../src/enhancers/withPersistTokens/index.ts","../../src/sdk/webauthn.ts","../../src/apiPaths.ts","../../src/sdk/fedcm.ts","../../src/sdk/flow.ts","../../src/sdk/oidc/helpers.ts","../../src/sdk/oidc/index.ts","../../src/index.ts","../../src/enhancers/helpers/compose.ts","../../src/enhancers/withAutoRefresh/index.ts","../../src/enhancers/withAnalytics.ts","../../src/enhancers/withFlowNonce/index.ts","../../src/sdk/index.ts"],"sourcesContent":["import { JWTResponse, UserResponse } from '@descope/core-js-sdk';\nimport { CoreSdkConfig, WebJWTResponse, WebSigninResponse } from '../../types';\nimport { jwtDecode, JwtPayload } from 'jwt-decode';\n\nconst getExpirationFromToken = (token: string) => {\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    return claims.exp;\n  } catch (e) {\n    return null;\n  }\n};\n\nconst oidcRefreshTokenExpiration = (response: WebSigninResponse) => {\n  const { refresh_expire_in, refresh_token } = response;\n  if (refresh_expire_in) {\n    return Math.floor(Date.now() / 1000) + refresh_expire_in;\n  }\n  return getExpirationFromToken(refresh_token);\n};\n\nconst oidcAccessTokenExpiration = (response: WebSigninResponse) => {\n  // oidc-client-ts may return the expiration time in\n  // - the expires_at (timestamp in seconds)\n  // - the expires_in (ttl in seconds)\n  // - we also fallback to the token itself\n  const { expires_in, expires_at, access_token } = response;\n  if (expires_at) {\n    return expires_at;\n  }\n  if (expires_in) {\n    // get expiration time from the expires_in in seconds\n    return Math.floor(Date.now() / 1000) + expires_in;\n  }\n  if (access_token) {\n    // get expiration time from the token itself\n    return getExpirationFromToken(access_token);\n  }\n  return undefined;\n};\n\nconst normalizeWebJWTResponseToJWTResponse = (\n  response: WebSigninResponse,\n): WebJWTResponse => {\n  const { access_token, id_token, refresh_token, refresh_expire_in, ...rest } =\n    response;\n  return {\n    sessionJwt: response.sessionJwt || access_token,\n    idToken: id_token,\n    refreshJwt: response.refreshJwt || refresh_token,\n    sessionExpiration:\n      response.sessionExpiration || oidcAccessTokenExpiration(response),\n    cookieExpiration:\n      response.cookieExpiration ||\n      (oidcRefreshTokenExpiration(response) as number),\n    ...rest,\n  };\n};\n\n/**\n * Add hooks to an existing core-sdk config\n */\nexport const addHooks = <Config extends CoreSdkConfig>(\n  config: Config,\n  hooks: Config['hooks'],\n): Config => {\n  ['beforeRequest', 'afterRequest'].reduce(\n    (acc, key) => {\n      acc[key] = []\n        .concat(config.hooks?.[key] || [])\n        .concat(hooks?.[key] || []);\n\n      return acc;\n    },\n    (config.hooks ??= {}),\n  );\n\n  return config;\n};\n\nexport { compose } from './compose';\n\n/**\n * Extract auth info (JWT response) from fetch response\n * We assume that the auth info is under a \"authInfo\" attribute (flow response)\n * Or the body itself (other auth methods response)\n */\nexport const getAuthInfoFromResponse = async (\n  res: Response,\n): Promise<Partial<WebJWTResponse>> => {\n  if (!res?.ok) return {};\n  const body = await res?.clone().json();\n  const authInfo = body?.authInfo || body || ({} as Partial<WebJWTResponse>);\n  return normalizeWebJWTResponseToJWTResponse(authInfo);\n};\n\n/**\n * Extract user from fetch response\n * User my exist under \"user\" attribute (auth methods response)\n * Or the body itself (when calling \"me\")\n */\nexport const getUserFromResponse = async (\n  res: Response,\n): Promise<UserResponse> | undefined => {\n  const authInfo = await getAuthInfoFromResponse(res);\n\n  return (\n    authInfo?.user ||\n    (authInfo?.hasOwnProperty('userId')\n      ? (authInfo as UserResponse)\n      : undefined)\n  );\n};\n\n// This window flag is set by mobile frameworks\nexport const isDescopeBridge = () =>\n  typeof window !== 'undefined' && !!window['descopeBridge'];\n\nexport const isLocalStorage = typeof localStorage !== 'undefined';\n\nexport const setLocalStorage = (key: string, value: string) =>\n  isLocalStorage && localStorage?.setItem(key, value);\nexport const getLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.getItem(key);\nexport const removeLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.removeItem(key);\n","const logger = {\n  debug: (...args: any[]) => {\n    // eslint-disable-next-line no-console\n    console.debug(...args);\n  },\n};\n\nexport default logger;\n","const OIDC_CLIENT_TS_VERSION = '3.2.0';\n\n// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n\n// Maximum timeout value for setTimeout\n// For more information, refer to https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\nexport const MAX_TIMEOUT = Math.pow(2, 31) - 1;\n\n// The amount of time (ms) to trigger the refresh before session expires\nexport const REFRESH_THRESHOLD = 20 * 1000; // 20 sec\n\nexport const OIDC_CLIENT_TS_DESCOPE_CDN_URL = `https://descopecdn.com/npm/oidc-client-ts@${OIDC_CLIENT_TS_VERSION}/dist/browser/oidc-client-ts.min.js`;\nexport const OIDC_CLIENT_TS_JSDELIVR_CDN_URL = `https://cdn.jsdelivr.net/npm/oidc-client-ts@${OIDC_CLIENT_TS_VERSION}/dist/browser/oidc-client-ts.min.js`;\n\nexport const OIDC_LOGOUT_ERROR_CODE = 'J161000';\nexport const OIDC_REFRESH_ERROR_CODE = 'J161001';\n","import { jwtDecode, JwtPayload } from 'jwt-decode';\nimport logger from '../helpers/logger';\nimport { MAX_TIMEOUT, REFRESH_THRESHOLD } from '../../constants';\n\n/**\n * Get the JWT expiration WITHOUT VALIDATING the JWT\n * @param token The JWT to extract expiration from\n * @returns The Date for when the JWT expires or null if there is an issue\n */\nexport const getTokenExpiration = (\n  token: string,\n  sessionExpiration: number,\n) => {\n  if (sessionExpiration) {\n    return new Date(sessionExpiration * 1000);\n  }\n\n  logger.debug(\n    'Could not extract expiration time from session token, trying to decode the token',\n  );\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    if (claims.exp) {\n      return new Date(claims.exp * 1000);\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const millisecondsUntilDate = (date: Date) =>\n  date ? date.getTime() - new Date().getTime() : 0;\n\nexport const createTimerFunctions = () => {\n  const timerIds: NodeJS.Timeout[] = [];\n\n  const clearAllTimers = () => {\n    while (timerIds.length) {\n      clearTimeout(timerIds.pop());\n    }\n  };\n\n  const setTimer = (cb: () => void, timeout: number) => {\n    timerIds.push(setTimeout(cb, timeout));\n  };\n\n  return { clearAllTimers, setTimer };\n};\n\nexport const getAutoRefreshTimeout = (sessionExpiration: Date) => {\n  let timeout = millisecondsUntilDate(sessionExpiration) - REFRESH_THRESHOLD;\n\n  if (timeout > MAX_TIMEOUT) {\n    logger.debug(\n      `Timeout is too large (${timeout}ms), setting it to ${MAX_TIMEOUT}ms`,\n    );\n    timeout = MAX_TIMEOUT;\n  }\n\n  return timeout;\n};\n","/** Default name for the session cookie name / local storage key */\nexport const SESSION_TOKEN_KEY = 'DS';\n/** Default name for the refresh local storage key */\nexport const REFRESH_TOKEN_KEY = 'DSR';\n/* Default name for the id token local storage key */\nexport const ID_TOKEN_KEY = 'DSI';\n","import { JWTResponse } from '@descope/core-js-sdk';\nimport Cookies from 'js-cookie';\nimport { BeforeRequestHook, WebJWTResponse } from '../../types';\nimport {\n  ID_TOKEN_KEY,\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './constants';\nimport {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport { CookieConfig, SameSite } from './types';\n\n/**\n * Store the session JWT as a cookie on the given domain and path with the given expiration.\n * This is useful so that the application backend will automatically get the cookie for the session\n * @param name cookie name\n * @param value The JWT to store as a cookie\n * @param cookieParams configuration that is usually returned from the JWT\n */\nfunction setJwtTokenCookie(\n  name: string,\n  value: string,\n  authInfo: Partial<\n    WebJWTResponse & { cookieSameSite: SameSite; cookieSecure: boolean }\n  >,\n) {\n  if (value) {\n    const {\n      cookieDomain,\n      cookiePath,\n      cookieSameSite,\n      cookieExpiration,\n      cookieSecure,\n    } = authInfo;\n    const expires = new Date(cookieExpiration * 1000); // we are getting response from the server in seconds instead of ms\n    // Since its a JS cookie, we don't set the domain because we want the cookie to be on the same domain as the application\n    const domainMatches = isCurrentDomainOrParentDomain(cookieDomain);\n    Cookies.set(name, value, {\n      path: cookiePath,\n      domain: domainMatches ? cookieDomain : undefined,\n      expires,\n      sameSite: cookieSameSite,\n      secure: cookieSecure,\n    });\n  }\n}\n\n/*\n * Check if the cookie domain is the same as the current domain or the parent domain\n * Examples:\n * 1. cookie domain: 'example.com', current domain: 'example.com' => true\n * 2. cookie domain: 'example.com', current domain: 'sub.example.com' => true\n * 3. cookie domain: 'example.com', current domain: 'sub.sub.example.com' => true\n * 4. cookie domain: 'example.com', current domain: 'another.com' => false\n * 5. cookie domain: 'example.com', current domain: 'example.co.il' => false\n */\nfunction isCurrentDomainOrParentDomain(cookieDomain: string): boolean {\n  const currentDomain = window.location.hostname;\n  const currentDomainParts = currentDomain.split('.');\n  const cookieDomainParts = cookieDomain.split('.');\n\n  // check if the cookie domain items are the last items in the current domain\n  const currentDomainSuffix = currentDomainParts\n    .slice(-cookieDomainParts.length)\n    .join('.');\n  return currentDomainSuffix === cookieDomain;\n}\n\nexport const persistTokens = (\n  authInfo = {} as Partial<WebJWTResponse>,\n  sessionTokenViaCookie: boolean | CookieConfig = false,\n  storagePrefix = '',\n) => {\n  // persist refresh token\n  const { sessionJwt, refreshJwt } = authInfo;\n  refreshJwt &&\n    setLocalStorage(`${storagePrefix}${REFRESH_TOKEN_KEY}`, refreshJwt);\n\n  // persist session token\n  if (sessionJwt) {\n    if (sessionTokenViaCookie) {\n      // Cookie configs will fallback to default values in both cases\n      // 1. sessionTokenViaCookie is a boolean\n      // 2. sessionTokenViaCookie is an object without the property\n      const cookieSameSite = sessionTokenViaCookie['sameSite'] || 'Strict';\n      const cookieSecure = sessionTokenViaCookie['secure'] ?? true;\n      setJwtTokenCookie(SESSION_TOKEN_KEY, sessionJwt, {\n        ...(authInfo as Partial<JWTResponse>),\n        cookieSameSite,\n        cookieSecure,\n      });\n    } else {\n      setLocalStorage(`${storagePrefix}${SESSION_TOKEN_KEY}`, sessionJwt);\n    }\n  }\n\n  if (authInfo.idToken) {\n    setLocalStorage(`${storagePrefix}${ID_TOKEN_KEY}`, authInfo.idToken);\n  }\n};\n\n/** Return the refresh token from the localStorage. Not for production usage because refresh token will not be saved in localStorage. */\nexport function getRefreshToken(prefix: string = '') {\n  return getLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`) || '';\n}\n\n/**\n * Return the session token. first try to get from cookie, and fallback to local storage\n * See sessionTokenViaCookie option for more details about session token location\n */\nexport function getSessionToken(prefix: string = ''): string {\n  return (\n    Cookies.get(SESSION_TOKEN_KEY) ||\n    getLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`) ||\n    ''\n  );\n}\n\nexport function getIdToken(prefix: string = ''): string {\n  return getLocalStorage(`${prefix}${ID_TOKEN_KEY}`) || '';\n}\n\n/** Remove both the localStorage refresh JWT and the session cookie */\nexport function clearTokens(prefix: string = '') {\n  removeLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${ID_TOKEN_KEY}`);\n  Cookies.remove(SESSION_TOKEN_KEY);\n}\n\nexport const beforeRequest =\n  (prefix?: string): BeforeRequestHook =>\n  (config) => {\n    return Object.assign(config, {\n      token: config.token || getRefreshToken(prefix),\n    });\n  };\n","import { IS_BROWSER } from '../../constants';\n\nconst FINGERPRINT_PUBLIC_KEY = 'fingerprint.public.key';\nconst FINGERPRINT_ENDPOINT_URL = 'fingerprint.endpoint.url';\n\n/** Fingerprint.js cloudflare integration */\nexport const FP_EP_URL =\n  (IS_BROWSER && localStorage?.getItem(FINGERPRINT_ENDPOINT_URL)) ||\n  'https://api.descope.com';\nexport const FP_CF_ENDPOINT_PATH = '/fXj8gt3x8VulJBna/x96Emn69oZwcd7I6';\nexport const FP_CF_SCRIPT_PATH = '/fXj8gt3x8VulJBna/w78aRZnnDZ3Aqw0I';\n/** Fingerprint visitor data */\nexport const FP_BODY_DATA = 'fpData';\n/** Session ID for visitor */\nexport const VISITOR_SESSION_ID_PARAM = 'vsid';\n/** Request ID for visitor */\nexport const VISITOR_REQUEST_ID_PARAM = 'vrid';\n/** FP storage key */\nexport const FP_STORAGE_KEY = 'fp';\n// Storage FP Keys TTL is 24 hours\nexport const STORAGE_TTL_MS = 24 * 60 * 60 * 1000;\n","import {\n  load,\n  defaultEndpoint,\n  defaultScriptUrlPattern,\n} from '@fingerprintjs/fingerprintjs-pro';\nimport {\n  FP_EP_URL,\n  FP_CF_ENDPOINT_PATH,\n  FP_CF_SCRIPT_PATH,\n  FP_STORAGE_KEY,\n  STORAGE_TTL_MS,\n  VISITOR_REQUEST_ID_PARAM,\n  VISITOR_SESSION_ID_PARAM,\n} from './constants';\nimport { FingerprintObject } from './types';\n\nconst createFingerprintObject = (\n  sessionId: string,\n  requestId: string,\n): FingerprintObject => ({\n  [VISITOR_SESSION_ID_PARAM]: sessionId,\n  [VISITOR_REQUEST_ID_PARAM]: requestId,\n});\n\n/** Generate UUID based on current time and some randomness */\nconst generateUUID = () => {\n  // return alphanumeric, sortable uuid of 27 characters\n  return (\n    Date.now().toString(36) +\n    Math.random().toString(36).substring(2) + // removing '0.' prefix\n    Math.random().toString(36).substring(2)\n  ).substring(0, 27);\n};\n\n// Set FP data to storage with expiration\n// We set the request id and session id together so they will have the same TTL\n// This implementation is based on https://www.sohamkamani.com/javascript/localstorage-with-ttl-expiry/\nconst setFPToStorage = (value: FingerprintObject) => {\n  const now = new Date();\n  // `item` is an object which contains the value\n  // as well as the time when it's supposed to expire\n  const item = {\n    value,\n    expiry: now.getTime() + STORAGE_TTL_MS,\n  };\n  localStorage.setItem(FP_STORAGE_KEY, JSON.stringify(item));\n};\n\n// Get Fingerprint from storage, will return null if not exists, or if expired\nconst getFPFromStorage = (returnExpired = false): FingerprintObject => {\n  const itemStr = localStorage.getItem(FP_STORAGE_KEY);\n  // if the item doesn't exist, return null\n  if (!itemStr) {\n    return null;\n  }\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  // compare the expiry time of the item with the current time\n  // return null if needed\n  if (now.getTime() > item.expiry && !returnExpired) {\n    return null;\n  }\n  return item.value;\n};\n\n/**\n * Ensure fingerprint ids (request id, session id) exist.\n * If not, It will generate and load them into to browser storage.\n * NOTE: Using fingerprintJS data has cost, use considerably.\n * @param fpKey FingerprintJS API key\n */\nexport const ensureFingerprintIds = async (\n  fpKey: string,\n  baseUrl = FP_EP_URL,\n) => {\n  try {\n    if (getFPFromStorage()) {\n      // FP is already in storage, no need to\n      return;\n    }\n\n    const sessionId = generateUUID();\n\n    const endpointUrl = new URL(baseUrl);\n    endpointUrl.pathname = FP_CF_ENDPOINT_PATH;\n\n    const patterUrl = new URL(baseUrl);\n    patterUrl.pathname = FP_CF_SCRIPT_PATH;\n    const scriptUrlPattern =\n      patterUrl.toString() +\n      '?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>';\n\n    // load from FingerprintJS\n    const agentP = load({\n      apiKey: fpKey,\n      endpoint: [\n        endpointUrl.toString(),\n        defaultEndpoint, // Fallback to default endpoint in case of error\n      ],\n      scriptUrlPattern: [\n        scriptUrlPattern,\n        defaultScriptUrlPattern, // Fallback to default CDN in case of error\n      ],\n    });\n\n    const agent = await agentP;\n    const { requestId } = await agent.get({ linkedId: sessionId });\n    const fpData = createFingerprintObject(sessionId, requestId);\n    setFPToStorage(fpData);\n  } catch (ex) {\n    // eslint-disable-next-line no-console\n    console.warn('Could not load fingerprint', ex);\n  }\n};\n\n/**\n * Get Fingerprint data (request ids) from storage, or create empty object\n * If data is expired, return it anyway\n */\nexport const getFingerprintData = (): FingerprintObject | null => {\n  // get from storage if exists\n  return getFPFromStorage(true);\n};\n\n/** Clear Fingerprint data from storage */\nexport const clearFingerprintData = () => {\n  localStorage.removeItem(FP_STORAGE_KEY);\n};\n","import { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport { FP_BODY_DATA } from './constants';\nimport { ensureFingerprintIds, getFingerprintData } from './helpers';\nimport { FingerprintOptions } from './types';\n\nconst beforeRequest: BeforeRequestHook = (config) => {\n  const data = getFingerprintData();\n  if (data && config.body) {\n    config.body[FP_BODY_DATA] = data;\n  }\n\n  return config;\n};\n\n/**\n * Add fingerprint data to outgoing requests\n */\nexport const withFingerprint =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ fpKey, fpLoad, ...config }: Parameters<T>[0] & FingerprintOptions) => {\n    if (!IS_BROWSER) {\n      // Fingerprint is a client side only capability and will not work when running in the server (SSR)\n      return createSdk(config);\n    }\n\n    // load fingerprint now if needed\n    if (fpKey && fpLoad) {\n      ensureFingerprintIds(fpKey).catch(\n        // istanbul ignore next\n        () => null,\n      );\n    }\n\n    // Hook added always because fingerprint can be dynamic using flows\n    return createSdk(addHooks(config, { beforeRequest }));\n  };\n","export const FLOW_NONCE_PREFIX = 'descopeFlowNonce';\nexport const FLOW_NONCE_HEADER = 'X-Descope-Flow-Nonce';\n\nexport const FLOW_START_PATH = '/v1/flow/start';\nexport const FLOW_NEXT_PATH = '/v1/flow/next';\n\nexport const FLOW_NEXT_TTL = 3 * 60 * 60; // 3 hours in seconds\nexport const FLOW_START_TTL = 2 * 24 * 60 * 60; // 2 days in seconds\n","import { RequestConfig } from '@descope/core-js-sdk';\nimport {\n  getLocalStorage,\n  isLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  FLOW_NEXT_PATH,\n  FLOW_NEXT_TTL,\n  FLOW_NONCE_HEADER,\n  FLOW_NONCE_PREFIX,\n  FLOW_START_TTL,\n} from './constants';\nimport { StorageItem } from './types';\n\n// Helper to create storage key from execution ID\nconst getNonceKeyForExecution = (\n  executionId: string,\n  prefix: string = FLOW_NONCE_PREFIX,\n): string => {\n  return `${prefix}${executionId}`;\n};\n\n// Get nonce from storage with expiration check\nconst getFlowNonce = (\n  executionId: string,\n  prefix: string = FLOW_NONCE_PREFIX,\n): string | null => {\n  try {\n    const key = getNonceKeyForExecution(executionId, prefix);\n    const itemStr = getLocalStorage(key);\n\n    if (!itemStr) {\n      return null;\n    }\n\n    const item: StorageItem = JSON.parse(itemStr);\n\n    if (item.expiry < Date.now()) {\n      removeFlowNonce(executionId, prefix);\n      return null;\n    }\n\n    return item.value;\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error getting flow nonce:', e);\n    return null;\n  }\n};\n\n// Store nonce with appropriate TTL\nconst setFlowNonce = (\n  executionId: string,\n  nonce: string,\n  isStart: boolean,\n  prefix: string = FLOW_NONCE_PREFIX,\n): void => {\n  try {\n    const key = getNonceKeyForExecution(executionId, prefix);\n    const ttlSeconds = isStart ? FLOW_START_TTL : FLOW_NEXT_TTL;\n\n    const item: StorageItem = {\n      value: nonce,\n      expiry: Date.now() + ttlSeconds * 1000,\n      isStart,\n    };\n\n    setLocalStorage(key, JSON.stringify(item));\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error setting flow nonce:', e);\n  }\n};\n\n// Remove nonce from storage\nconst removeFlowNonce = (\n  executionId: string,\n  prefix: string = FLOW_NONCE_PREFIX,\n): void => {\n  try {\n    const key = getNonceKeyForExecution(executionId, prefix);\n    removeLocalStorage(key);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error removing flow nonce:', e);\n  }\n};\n\n// Extract execution ID from special format\nconst extractExecId = (executionId: string): string | null => {\n  const regex = /.*\\|#\\|(.*)/;\n  return regex.exec(executionId)?.[1] || null;\n};\n\n// Extract nonce and execution ID from response\nconst extractFlowNonce = async (\n  req: RequestConfig,\n  response: Response,\n): Promise<{ nonce: string | null; executionId: string | null }> => {\n  try {\n    const nonce = response.headers.get(FLOW_NONCE_HEADER);\n\n    // Clone the response to prevent body consumption\n    let executionId = await response\n      .clone()\n      .json()\n      .then((data) => data?.executionId || null)\n      .catch(() => null);\n\n    if (!executionId) {\n      // Fallback to request\n      executionId = getExecutionIdFromRequest(req);\n    }\n\n    return {\n      nonce,\n      executionId: extractExecId(executionId),\n    };\n  } catch (e) {\n    return { nonce: null, executionId: null };\n  }\n};\n\n// Get execution ID from request object\nconst getExecutionIdFromRequest = (req: RequestConfig): string | null => {\n  if (req.path === FLOW_NEXT_PATH && req.body?.executionId) {\n    return extractExecId(req.body.executionId);\n  }\n\n  return null;\n};\n\n// Remove expired nonces from storage\nconst cleanupExpiredNonces = (prefix: string = FLOW_NONCE_PREFIX): void => {\n  try {\n    if (!isLocalStorage) {\n      return;\n    }\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n\n      if (key && key.startsWith(prefix)) {\n        const itemStr = getLocalStorage(key);\n\n        if (itemStr) {\n          try {\n            const item: StorageItem = JSON.parse(itemStr);\n\n            if (item.expiry < Date.now()) {\n              removeLocalStorage(key);\n            }\n          } catch (parseError) {\n            removeLocalStorage(key);\n          }\n        }\n      }\n    }\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error cleaning up expired nonces:', e);\n  }\n};\n\nexport {\n  cleanupExpiredNonces,\n  extractFlowNonce,\n  getExecutionIdFromRequest,\n  getFlowNonce,\n  getNonceKeyForExecution,\n  removeFlowNonce,\n  setFlowNonce,\n};\n","/** Login Id of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_LOGIN_ID = 'dls_last_user_login_id';\n\n/** Display name of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_DISPLAY_NAME =\n  'dls_last_user_display_name';\n","import {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  LOCAL_STORAGE_LAST_USER_LOGIN_ID,\n  LOCAL_STORAGE_LAST_USER_DISPLAY_NAME,\n} from './constants';\n\nexport const setLastUserLoginId = (loginId: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID, loginId);\n};\n\nexport const getLastUserLoginId = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const removeLastUserLoginId = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const setLastUserDisplayName = (displayName: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME, displayName);\n};\n\nexport const getLastUserDisplayName = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n\nexport const removeLastUserDisplayName = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, CoreSdk } from '../../types';\nimport { addHooks, getUserFromResponse } from '../helpers';\nimport {\n  getLastUserLoginId,\n  removeLastUserLoginId,\n  setLastUserLoginId,\n  getLastUserDisplayName,\n  removeLastUserDisplayName,\n  setLastUserDisplayName,\n} from './helpers';\nimport { LastLoggedInUserOptions } from './types';\n\n/**\n * Adds last logged in user to flow start request\n */\n// eslint-disable-next-line import/exports-last\nexport const withLastLoggedInUser =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({\n    storeLastAuthenticatedUser = true,\n    keepLastAuthenticatedUserAfterLogout = false,\n    ...config\n  }: Parameters<T>[0] & LastLoggedInUserOptions): ReturnType<T> & {\n    getLastUserLoginId: typeof getLastUserLoginId;\n    getLastUserDisplayName: typeof getLastUserDisplayName;\n  } => {\n    if (!storeLastAuthenticatedUser) {\n      // We assign getLastUserLoginId and getLastUserDisplayName to the sdk\n      // To keep the return type consistent\n      return Object.assign(createSdk(config), {\n        getLastUserLoginId,\n        getLastUserDisplayName,\n      }) as any;\n    }\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const userDetails = await getUserFromResponse(res);\n      const loginId = userDetails?.loginIds?.[0];\n      const displayName = userDetails?.name;\n      if (loginId) {\n        setLastUserLoginId(loginId);\n        setLastUserDisplayName(displayName);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    let wrappedSdk = wrapWith(sdk, ['flow.start'], startWrapper);\n    wrappedSdk = wrapWith(\n      wrappedSdk,\n      ['logout', 'logoutAll'],\n      logoutWrapper(keepLastAuthenticatedUserAfterLogout),\n    );\n    return Object.assign(wrappedSdk, {\n      getLastUserLoginId,\n      getLastUserDisplayName,\n    }) as any;\n  };\n\nconst startWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    args[1] = args[1] || {};\n    const [, options = {}] = args as unknown as Parameters<\n      CoreSdk['flow']['start']\n    >;\n    const loginId = getLastUserLoginId();\n    const displayName = getLastUserDisplayName();\n\n    if (loginId) {\n      options.lastAuth ??= {};\n      options.lastAuth.loginId = loginId;\n      options.lastAuth.name = displayName;\n    }\n\n    const resp = await fn(...args);\n\n    return resp;\n  };\n\nconst logoutWrapper =\n  (keepOnLogout?: boolean): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n    if (keepOnLogout) {\n      return resp;\n    }\n\n    removeLastUserLoginId();\n    removeLastUserDisplayName();\n\n    return resp;\n  };\n","// create publisher/subscriber instances\nexport function createPubSub<T extends any>() {\n  const cbs = [];\n\n  const sub = (cb: (data: T) => void) => {\n    const idx = cbs.push(cb) - 1;\n    return () => cbs.splice(idx, 1);\n  };\n\n  const pub = (data: T) => {\n    cbs.forEach((cb) => cb(data));\n  };\n\n  return { pub, sub };\n}\n","import { SdkFnWrapper, UserResponse, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk, WebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport {\n  addHooks,\n  getAuthInfoFromResponse,\n  getUserFromResponse,\n} from '../helpers';\nimport { createPubSub } from './helpers';\n\n/**\n * Adds 3 event functions to the sdk,\n * onSessionTokenChange: Gets a callback and call it whenever there is a change in session token\n * onIsAuthenticatedChange: Gets a callback and call it whenever there is a change in authentication status\n * onUserChange: Gets a callback and call it whenever there is a change in current logged in user\n */\nexport const withNotifications =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) => {\n    const sessionExpirationPS = createPubSub<number | null>();\n    const sessionPS = createPubSub<string | null>();\n    const userPS = createPubSub<UserResponse | null>();\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        sessionPS.pub(null);\n        userPS.pub(null);\n        sessionExpirationPS.pub(null);\n      } else {\n        const userDetails = await getUserFromResponse(res);\n        if (userDetails) userPS.pub(userDetails);\n\n        const { sessionJwt, sessionExpiration } =\n          await getAuthInfoFromResponse(res);\n\n        if (sessionJwt) sessionPS.pub(sessionJwt);\n\n        if (sessionExpiration || sessionJwt) {\n          // We also publish the session expiration if there is a session jwt\n          // as a temporary fix for the issue where the session expiration is not\n          // being sent in the response in Flows (42 is a magic number)\n          sessionExpirationPS.pub(sessionExpiration || 42);\n        }\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n\n        sessionPS.pub(null);\n        userPS.pub(null);\n        sessionExpirationPS.pub(null);\n\n        return resp;\n      };\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll', 'oidc.logout'],\n      wrapper,\n    );\n\n    return Object.assign(wrappedSdk, {\n      onSessionTokenChange: sessionPS.sub,\n      onUserChange: userPS.sub,\n      onIsAuthenticatedChange: (cb: (isAuthenticated: boolean) => void) => {\n        // If and only if there is a session expiration, then the user is authenticated\n        return sessionExpirationPS.sub((exp) => {\n          cb(!!exp);\n        });\n      },\n    });\n  };\n","/* eslint-disable import/exports-last */\nimport { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  beforeRequest,\n  clearTokens,\n  getRefreshToken,\n  getSessionToken,\n  persistTokens,\n  getIdToken,\n} from './helpers';\nimport { CookieConfig, PersistTokensOptions } from './types';\n\n/**\n * Persist authentication tokens in cookie/storage\n */\nexport const withPersistTokens =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  <A extends CookieConfig>({\n    persistTokens: isPersistTokens,\n    sessionTokenViaCookie,\n    storagePrefix,\n    ...config\n  }: Parameters<T>[0] & PersistTokensOptions<A>): A extends false\n    ? ReturnType<T>\n    : ReturnType<T> & {\n        getRefreshToken: () => string;\n        getSessionToken: () => string;\n        getIdToken: () => string;\n      } => {\n    if (!isPersistTokens || !IS_BROWSER) {\n      if (isPersistTokens) {\n        // Storing auth tokens in local storage and cookies are a client side only capabilities\n        // and will not be done when running in the server\n      }\n      return createSdk(config) as any;\n    }\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      const isManagementApi = /^\\/v\\d+\\/mgmt\\//.test(req.path);\n\n      if (res?.status === 401) {\n        if (!isManagementApi) {\n          clearTokens(storagePrefix);\n        }\n      } else {\n        persistTokens(\n          await getAuthInfoFromResponse(res),\n          sessionTokenViaCookie,\n          storagePrefix,\n        );\n      }\n    };\n\n    const sdk = createSdk(\n      addHooks(config, {\n        beforeRequest: beforeRequest(storagePrefix),\n        afterRequest,\n      }),\n    );\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll', 'oidc.logout'],\n      wrapper(storagePrefix),\n    );\n\n    const refreshToken = () => getRefreshToken(storagePrefix);\n    const sessionToken = () => getSessionToken(storagePrefix);\n    const idToken = () => getIdToken(storagePrefix);\n\n    return Object.assign(wrappedSdk, {\n      getRefreshToken: refreshToken,\n      getSessionToken: sessionToken,\n      getIdToken: idToken,\n    }) as any;\n  };\n\nconst wrapper =\n  (prefix?: string): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    clearTokens(prefix);\n\n    return resp;\n  };\n\nexport default withPersistTokens;\n","import { JWTResponse, SdkResponse, ResponseData } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../constants';\nimport { CoreSdk, PasskeyOptions } from '../types';\n\ntype CreateWebauthn = typeof createWebAuthn;\n\nconst withCoreFns =\n  <I extends Parameters<CreateWebauthn>, O extends ReturnType<CreateWebauthn>>(\n    creator: (...args: I) => O,\n  ) =>\n  (...args: I) => {\n    const obj = creator(...args);\n\n    Object.assign(obj.signUp, args[0].webauthn.signUp);\n    Object.assign(obj.signIn, args[0].webauthn.signIn);\n    Object.assign(obj.signUpOrIn, args[0].webauthn.signUpOrIn);\n    Object.assign(obj.update, args[0].webauthn.update);\n\n    return obj as {\n      [K in keyof O]: K extends keyof I[0]['webauthn']\n        ? O[K] & I[0]['webauthn'][K]\n        : O[K];\n    };\n  };\n\n/** Constructs a higher level WebAuthn API that wraps the functions from code-js-sdk */\nconst createWebAuthn = (sdk: CoreSdk) => ({\n  async signUp(\n    identifier: string,\n    name: string,\n    passkeyOptions?: PasskeyOptions,\n  ) {\n    const startResponse = await sdk.webauthn.signUp.start(\n      identifier,\n      window.location.origin,\n      name,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signUp.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  async signIn(identifier: string, passkeyOptions?: PasskeyOptions) {\n    const startResponse = await sdk.webauthn.signIn.start(\n      identifier,\n      window.location.origin,\n      undefined,\n      undefined,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const getResponse = await get(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signIn.finish(\n      startResponse.data.transactionId,\n      getResponse,\n    );\n    return finishResponse;\n  },\n\n  async signUpOrIn(identifier: string, passkeyOptions?: PasskeyOptions) {\n    const startResponse = await sdk.webauthn.signUpOrIn.start(\n      identifier,\n      window.location.origin,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    if (startResponse.data?.create) {\n      const createResponse = await create(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signUp.finish(\n        startResponse.data.transactionId,\n        createResponse,\n      );\n      return finishResponse;\n    } else {\n      const getResponse = await get(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signIn.finish(\n        startResponse.data.transactionId,\n        getResponse,\n      );\n      return finishResponse;\n    }\n  },\n\n  async update(\n    identifier: string,\n    token?: string,\n    passkeyOptions?: PasskeyOptions,\n  ) {\n    const startResponse = await sdk.webauthn.update.start(\n      identifier,\n      window.location.origin,\n      token,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as SdkResponse<ResponseData>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.update.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  /** Helper functions for working with WebAuthn browser APIs using JSON data */\n  helpers: {\n    /** Wraps the navigation.credentials.create call to translate JSON inputs and outputs */\n    create,\n    /** Wraps the navigation.credentials.get call to translate JSON inputs and outputs */\n    get,\n    /** Checks if the browser supports WebAuthn, and can optionally require in\n     * addition that the browser supports WebAuthn with built-in biometrics */\n    isSupported,\n    conditional,\n  },\n});\n\n// Helpers functions\n\nasync function create(options: string): Promise<string> {\n  const createOptions = decodeCreateOptions(options);\n  const createResponse = (await navigator.credentials.create(\n    createOptions,\n  )) as AttestationPublicKeyCredential;\n  return encodeCreateResponse(createResponse);\n}\n\nasync function get(options: string): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n/**\n * This function should be used in passkeys autofill (conditional UI)\n * It handles the call to \"navigator.credentials.get\" and adds the required options\n * @param options webauthn start options\n * @param abort: AbortController instance\n * @returns encoded \"navigator.credentials.get\" response\n */\nasync function conditional(\n  options: string,\n  abort: AbortController,\n): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  getOptions.signal = abort.signal;\n  getOptions.mediation = 'conditional' as any;\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n// eslint-disable-next-line import/exports-last\nexport async function isSupported(\n  requirePlatformAuthenticator: boolean = false,\n): Promise<boolean> {\n  if (!IS_BROWSER) {\n    return Promise.resolve(false);\n  }\n  const supported = !!(\n    window.PublicKeyCredential &&\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get\n  );\n  if (\n    supported &&\n    requirePlatformAuthenticator &&\n    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable\n  ) {\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  }\n  return supported;\n}\n\n// Conversion of data structures for Create/Attestation/Register ceremony\n\ntype AttestationPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAttestationResponse;\n};\n\nfunction decodeCreateOptions(value: string): CredentialCreationOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.user.id = decodeBase64Url(options.publicKey.user.id);\n  options.publicKey.excludeCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeCreateResponse(\n  credential: AttestationPublicKeyCredential,\n): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      attestationObject: encodeBase64Url(credential.response.attestationObject),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n    },\n  });\n}\n\n// Conversion of data structures for Get/Assertion/Login ceremony\n\ntype AssertionPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAssertionResponse;\n};\n\nfunction decodeGetOptions(value: string): CredentialRequestOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.allowCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeGetResponse(credential: AssertionPublicKeyCredential): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      authenticatorData: encodeBase64Url(credential.response.authenticatorData),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n      signature: encodeBase64Url(credential.response.signature),\n      userHandle: credential.response.userHandle\n        ? encodeBase64Url(credential.response.userHandle)\n        : undefined,\n    },\n  });\n}\n\n// Conversion between ArrayBuffers and Base64Url strings\n\nfunction decodeBase64Url(value: string): ArrayBufferLike {\n  const base64 = value.replace(/_/g, '/').replace(/-/g, '+');\n  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;\n}\n\nfunction encodeBase64Url(value: ArrayBufferLike): string {\n  const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(value)));\n  return base64.replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '');\n}\n\n// Exports\nexport default withCoreFns(createWebAuthn);\n","export const apiPaths = {\n  fedcm: {\n    config: '/fedcm/config',\n  },\n};\n","import { JWTResponse, SdkResponse, LoginOptions } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport { IS_BROWSER } from '../constants';\nimport { apiPaths } from '../apiPaths';\n\n/**\n * Configuration for OneTap.\n */\ninterface OneTapConfig {\n  /** Whether to auto select. Optional. */\n  auto_select?: boolean;\n\n  /** Whether to cancel on tap outside. Optional. */\n  cancel_on_tap_outside?: boolean;\n\n  /** ID of the prompt parent. Optional. */\n  prompt_parent_id?: string;\n\n  /** Context. Optional. */\n  context?: 'signin' | 'signup' | 'use';\n\n  /** Callback function to handle the intermediate iframe close event. Optional. */\n  intermediate_iframe_close_callback?: () => void;\n\n  /** Whether to support ITP. Optional. */\n  itp_support?: boolean;\n\n  /** Login hint. Optional. */\n  login_hint?: string;\n\n  /** HD. Optional. */\n  hd?: string;\n\n  /** Whether to use FedCM for prompt. Optional. */\n  use_fedcm_for_prompt?: boolean;\n}\n\n/**\n * Response from the credential.\n */\ninterface CredentialResponse {\n  /** Credential. */\n  credential: string;\n\n  /** How the selection was made. */\n  select_by:\n    | 'auto'\n    | 'user'\n    | 'user_1tap'\n    | 'user_2tap'\n    | 'btn'\n    | 'btn_confirm'\n    | 'btn_add_session'\n    | 'btn_confirm_add_session';\n}\n\ninterface FedCMAssertionResponse {\n  token: string;\n  error: {\n    code: string;\n    url: string;\n  };\n}\n\ninterface IdentityProviderConfig {\n  configURL: string;\n  clientId: string;\n}\n\ntype IdentityCredentialRequestOptionsContext =\n  | 'signin'\n  | 'signup'\n  | 'use'\n  | 'continue';\n\ninterface IdentityProviderRequestOptions extends IdentityProviderConfig {\n  nonce?: string;\n  loginHint?: string;\n  domainHint?: string;\n}\n\ninterface IdentityCredentialRequestOptions {\n  providers: IdentityProviderRequestOptions[];\n  context?: IdentityCredentialRequestOptionsContext;\n}\n\ninterface FedCMCredentialRequestOptions {\n  identity?: IdentityCredentialRequestOptions;\n}\n\ntype OneTapInitialize = ({\n  client_id,\n  callback,\n  nonce,\n}: {\n  client_id: string;\n  callback: (res: CredentialResponse) => void;\n  nonce: string;\n} & OneTapConfig) => void;\n\ntype PromptNotification = {\n  isSkippedMoment: () => boolean;\n  isDismissedMoment: () => boolean;\n  getDismissedReason: () => string;\n  getSkippedReason: () => string;\n};\n\nconst generateNonce = () => {\n  if (window.crypto && window.crypto.getRandomValues) {\n    const array = new Uint8Array(16); // 16 bytes = 128 bits\n    window.crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join(\n      '',\n    );\n  } else {\n    // Fallback (not cryptographically secure)\n    return Math.random().toString(36).substring(2);\n  }\n};\n\n/**\n * Constructs a higher level FedCM API that wraps the functions from code-js-sdk.\n * @param sdk The CoreSdk instance.\n * @returns The FedCM API.\n */\nconst createFedCM = (sdk: CoreSdk, projectId: string) => ({\n  onetap: {\n    requestExchangeCode(options: {\n      provider?: string;\n      oneTapConfig?: OneTapConfig;\n      loginOptions?: LoginOptions;\n      onSkipped?: (reason?: string) => void;\n      onDismissed?: (reason?: string) => void;\n      onFailed?: (error: Error) => void;\n      onCodeReceived: (code: string) => void;\n    }) {\n      performOneTap(sdk, options);\n    },\n\n    requestAuthentication(options?: {\n      provider?: string;\n      oneTapConfig?: OneTapConfig;\n      loginOptions?: LoginOptions;\n      onSkipped?: (reason?: string) => void;\n      onDismissed?: (reason?: string) => void;\n      onFailed?: (error: Error) => void;\n      onAuthenticated?: (response: JWTResponse) => void;\n    }) {\n      performOneTap(sdk, options);\n    },\n  },\n\n  /**\n   * @deprecated Call `onetap.requestAuthentication` instead.\n   */\n  async oneTap(\n    provider?: string,\n    oneTapConfig?: OneTapConfig,\n    loginOptions?: LoginOptions,\n    onSkipped?: (reason?: string) => void,\n    onDismissed?: (reason?: string) => void,\n  ) {\n    await performOneTapAsync(sdk, {\n      provider,\n      oneTapConfig,\n      loginOptions,\n      onSkipped,\n      onDismissed,\n    });\n  },\n\n  async launch(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<SdkResponse<JWTResponse>> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    const req: FedCMCredentialRequestOptions = {\n      identity: {\n        context: context || 'signin',\n        providers: [\n          {\n            configURL,\n            clientId: projectId,\n          },\n        ],\n      },\n    };\n    const res = await navigator.credentials?.get(req as any);\n    return sdk.refresh((res as any as FedCMAssertionResponse).token);\n  },\n\n  isSupported(): boolean {\n    return IS_BROWSER && 'IdentityCredential' in window;\n  },\n\n  async isLoggedIn(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<boolean> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    try {\n      const req: FedCMCredentialRequestOptions = {\n        identity: {\n          context: context || 'signin',\n          providers: [\n            {\n              configURL,\n              clientId: projectId,\n            },\n          ],\n        },\n      };\n      const res = await navigator.credentials?.get(req as any);\n      return !!res && !!(res as any as FedCMAssertionResponse).token;\n    } catch (e) {\n      // Any error likely indicates no active session.\n      return false;\n    }\n  },\n});\n\n// Helpers functions\nasync function getGoogleClient(): Promise<{\n  initialize: OneTapInitialize;\n  prompt: (cb: (notification: PromptNotification) => void) => void;\n}> {\n  return new Promise((resolve, reject) => {\n    if ((window as any).google) {\n      resolve((window as any).google.accounts.id);\n      return;\n    }\n\n    /* istanbul ignore next */\n    let googleScript = document.getElementById(\n      'google-gsi-client-script',\n    ) as HTMLScriptElement;\n\n    /* istanbul ignore next */\n    if (!googleScript) {\n      googleScript = document.createElement('script');\n      document.head.appendChild(googleScript);\n      googleScript.async = true;\n      googleScript.defer = true;\n      googleScript.id = 'google-gsi-client-script';\n      googleScript.src = 'https://accounts.google.com/gsi/client';\n    }\n\n    /* istanbul ignore next */\n    googleScript.onload = function () {\n      if ((window as any).google) {\n        resolve((window as any).google.accounts.id);\n      } else {\n        reject('Failed to load Google GSI client script - not loaded properly');\n      }\n    };\n    /* istanbul ignore next */\n    googleScript.onerror = function () {\n      reject('Failed to load Google GSI client script - failed to load');\n    };\n  });\n}\n\nasync function performOneTap(\n  sdk: CoreSdk,\n  options?: {\n    provider?: string;\n    oneTapConfig?: OneTapConfig;\n    loginOptions?: LoginOptions;\n    onSkipped?: (reason?: string) => void;\n    onDismissed?: (reason?: string) => void;\n    onFailed?: (error: Error) => void;\n    onCodeReceived?: (code: string) => void;\n    onAuthenticated?: (response: JWTResponse) => void;\n  },\n) {\n  try {\n    await performOneTapAsync(sdk, options);\n  } catch (e) {\n    options?.onFailed?.(e);\n  }\n}\n\nasync function performOneTapAsync(\n  sdk: CoreSdk,\n  options?: {\n    provider?: string;\n    oneTapConfig?: OneTapConfig;\n    loginOptions?: LoginOptions;\n    onSkipped?: (reason?: string) => void;\n    onDismissed?: (reason?: string) => void;\n    onCodeReceived?: (code: string) => void;\n    onAuthenticated?: (response: JWTResponse) => void;\n  },\n) {\n  const auth = await startOneTap(\n    sdk,\n    options.provider,\n    options.oneTapConfig,\n    options.onSkipped,\n    options.onDismissed,\n  );\n  if (!auth.credential) {\n    return null;\n  }\n  if (options?.onCodeReceived) {\n    const response = await sdk.oauth.verifyOneTapIDToken(\n      auth.provider,\n      auth.credential,\n      auth.nonce,\n      options?.loginOptions,\n    );\n    if (!response.ok || !response.data) {\n      throw new Error(\n        'Failed to verify OneTap client ID for provider ' + auth.provider,\n      );\n    }\n    options?.onCodeReceived?.(response.data.code);\n  } else {\n    const response = await sdk.oauth.exchangeOneTapIDToken(\n      auth.provider,\n      auth.credential,\n      auth.nonce,\n      options?.loginOptions,\n    );\n    if (!response.ok || !response.data) {\n      throw new Error(\n        'Failed to exchange OneTap client ID for provider ' + auth.provider,\n      );\n    }\n    options?.onAuthenticated?.(response.data);\n  }\n}\n\nasync function startOneTap(\n  sdk: CoreSdk,\n  provider: string = 'google',\n  oneTapConfig?: OneTapConfig,\n  onSkipped?: (reason?: string) => void,\n  onDismissed?: (reason?: string) => void,\n): Promise<{\n  provider: string;\n  nonce: string;\n  credential?: string;\n}> {\n  const nonce = generateNonce();\n  const googleClient = await getGoogleClient();\n\n  const clientIdRes = await sdk.oauth.getOneTapClientId(provider);\n  if (!clientIdRes.ok) {\n    throw new Error('Failed to get OneTap client ID for provider ' + provider);\n  }\n  const clientId = clientIdRes.data.clientId;\n\n  return new Promise((resolve) => {\n    const callback = (response?: CredentialResponse) => {\n      resolve({\n        provider,\n        nonce,\n        credential: response?.credential,\n      });\n    };\n\n    googleClient.initialize({\n      ...oneTapConfig,\n      itp_support: oneTapConfig?.itp_support ?? true,\n      use_fedcm_for_prompt: oneTapConfig?.use_fedcm_for_prompt ?? true,\n      client_id: clientId,\n      callback,\n      nonce,\n    });\n\n    googleClient.prompt((notification) => {\n      if (onDismissed && notification?.isDismissedMoment()) {\n        const reason = notification.getDismissedReason?.();\n        onDismissed?.(reason);\n        callback();\n        return;\n      }\n\n      if (onSkipped && notification?.isSkippedMoment()) {\n        const reason = notification.getSkippedReason?.();\n        onSkipped?.(reason);\n        callback();\n        return;\n      }\n    });\n  });\n}\n\nexport default createFedCM;\nexport type { OneTapConfig };\n","import { CoreSdk, ReplaceParam } from '../types';\nimport { isSupported } from './webauthn';\n\ntype CoreSdkFlowStartArgs = Parameters<CoreSdk['flow']['start']>;\ntype Options = Pick<\n  CoreSdkFlowStartArgs[1],\n  | 'tenant'\n  | 'redirectUrl'\n  | 'redirectAuth'\n  | 'oidcIdpStateId'\n  | 'samlIdpStateId'\n  | 'samlIdpUsername'\n  | 'ssoAppId'\n  | 'thirdPartyAppId'\n  | 'oidcLoginHint'\n  | 'preview'\n  | 'abTestingKey'\n  | 'client'\n  | 'locale'\n  | 'oidcPrompt'\n  | 'oidcErrorRedirectUri'\n  | 'oidcResource'\n  | 'nativeOptions'\n  | 'thirdPartyAppStateId'\n  | 'applicationScopes'\n  | 'outboundAppId'\n  | 'outboundAppScopes'\n> & {\n  lastAuth?: Omit<CoreSdkFlowStartArgs[1]['lastAuth'], 'loginId' | 'name'>;\n};\n\nconst START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL = 1;\n\nexport default (coreSdk: CoreSdk) => ({\n  ...coreSdk.flow,\n  // wrap start fn and adds more data to the start options\n  start: async (...args: ReplaceParam<CoreSdkFlowStartArgs, '1', Options>) => {\n    const webAuthnSupport = await isSupported();\n    const decoratedOptions = {\n      location: window.location.href,\n      ...args[1],\n      deviceInfo: {\n        webAuthnSupport,\n      },\n      startOptionsVersion: START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL,\n    };\n\n    args[1] = decoratedOptions;\n\n    return coreSdk.flow.start(...args);\n  },\n});\n","export const hasOidcParamsInUrl = () => {\n  return (\n    window.location.search.includes('code') &&\n    window.location.search.includes('state')\n  );\n};\n\nexport const removeOidcParamFromUrl = () => {\n  // Retrieve the current URL from the browser's address bar\n  const currentUrl = new URL(window.location.href);\n\n  // Remove the 'code' and 'state' query parameters if it exist\n  currentUrl.searchParams.delete('code');\n  currentUrl.searchParams.delete('state');\n\n  // Update the URL displayed in the browser without reloading the page\n  window.history.replaceState({}, document.title, currentUrl.toString());\n};\n","import { RequestConfig, SdkResponse, URLResponse } from '@descope/core-js-sdk';\nimport type {\n  CreateSigninRequestArgs,\n  CreateSignoutRequestArgs,\n  OidcClient,\n  OidcClientSettings,\n  SigninResponse,\n  WebStorageStateStore,\n} from 'oidc-client-ts';\nimport {\n  OIDC_CLIENT_TS_DESCOPE_CDN_URL,\n  OIDC_CLIENT_TS_JSDELIVR_CDN_URL,\n} from '../../constants';\nimport { getIdToken } from '../../enhancers/withPersistTokens/helpers';\nimport { CoreSdk, OidcConfig, OidcConfigOptions } from '../../types';\nimport { hasOidcParamsInUrl, removeOidcParamFromUrl } from './helpers';\n\ntype OidcModule = {\n  OidcClient: typeof OidcClient;\n  WebStorageStateStore: typeof WebStorageStateStore;\n};\n\ntype SignInResponseStorage = Pick<\n  SigninResponse,\n  'id_token' | 'session_state' | 'profile'\n>;\n\nlet scriptLoadingPromise: Promise<OidcModule>;\n\n/* istanbul ignore next */\nconst simpleHash = (input: string): string => {\n  let hash = 0;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n\n  return Math.abs(hash).toString(16); // Return hash as a positive hexadecimal string\n};\n\nconst loadScriptWithFallback = (\n  urls: string[],\n  getEntry: () => OidcModule,\n): Promise<OidcModule> => {\n  /* istanbul ignore next */\n  return new Promise((resolve, reject) => {\n    if (!urls.length)\n      return reject(new Error('No URLs provided to loadScriptWithFallback'));\n\n    const entry = getEntry();\n    if (entry) return resolve(entry);\n\n    const url = urls.shift();\n\n    const scriptEle = document.createElement('script');\n    scriptEle.src = url;\n    scriptEle.id = simpleHash(url);\n    scriptEle.onload = () => {\n      const entry = getEntry();\n      if (entry) return resolve(entry);\n      throw new Error('Could not get entry after loading script from URL');\n    };\n    /* istanbul ignore next */\n    scriptEle.addEventListener('error', () => {\n      loadScriptWithFallback(urls, getEntry);\n      scriptEle.setAttribute('data-error', 'true');\n    });\n    document.body.appendChild(scriptEle);\n  });\n};\n\nconst loadOIDCModule = async (): Promise<OidcModule> => {\n  /* istanbul ignore next */\n  try {\n    return require('oidc-client-ts');\n  } catch (e) {\n    return loadScriptWithFallback(\n      [OIDC_CLIENT_TS_DESCOPE_CDN_URL, OIDC_CLIENT_TS_JSDELIVR_CDN_URL],\n      () => window['oidc'],\n    );\n  }\n};\n\nfunction oidcSignInResToStorage(\n  signInRes: SigninResponse,\n): SignInResponseStorage {\n  return {\n    id_token: signInRes.id_token,\n    session_state: signInRes.session_state,\n    profile: signInRes.profile,\n  };\n}\n\nconst getUserFromStorage = (\n  stateUserKey: string,\n): SignInResponseStorage | null => {\n  const user = window.localStorage.getItem(stateUserKey);\n  return user ? JSON.parse(user) : null;\n};\n\nconst getOidcClient = async (\n  sdk: CoreSdk,\n  projectId: string,\n  oidcConfig?: OidcConfigOptions,\n) => {\n  if (!scriptLoadingPromise) {\n    scriptLoadingPromise = loadOIDCModule();\n  }\n  const { OidcClient, WebStorageStateStore } = await scriptLoadingPromise;\n\n  if (!OidcClient) {\n    throw new Error(\n      'oidc-client-ts is not installed. Please install it by running `npm install oidc-client-ts`',\n    );\n  }\n\n  const clientId = projectId;\n  const redirectUri = oidcConfig?.redirectUri || window.location.href;\n  const scope =\n    oidcConfig?.scope ||\n    'openid email roles descope.custom_claims offline_access';\n  const stateUserKey = `${clientId}_user`;\n\n  let authority = sdk.httpClient.buildUrl(projectId);\n  if (oidcConfig?.applicationId) {\n    // append the applicationId to the authority\n    authority = `${authority}/${oidcConfig.applicationId}`;\n  }\n\n  const settings: OidcClientSettings = {\n    authority,\n    client_id: projectId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    scope,\n    stateStore: new WebStorageStateStore({\n      store: window.localStorage,\n      prefix: clientId,\n    }),\n    loadUserInfo: true,\n    fetchRequestCredentials: 'same-origin',\n  };\n\n  if (oidcConfig?.redirectUri) {\n    settings.redirect_uri = oidcConfig.redirectUri;\n  }\n  if (oidcConfig?.scope) {\n    settings.scope = oidcConfig.scope;\n  }\n  return {\n    client: new OidcClient(settings),\n    stateUserKey,\n  };\n};\n\nconst createOidc = (\n  sdk: CoreSdk,\n  projectId: string,\n  oidcConfig?: OidcConfig,\n) => {\n  const getCachedClient = async (): Promise<{\n    client: OidcClient;\n    stateUserKey: string;\n  }> => {\n    let client, stateUserKey;\n    if (!client || !stateUserKey) {\n      ({ client, stateUserKey } = await getOidcClient(\n        sdk,\n        projectId,\n        oidcConfig as OidcConfigOptions,\n      ));\n    }\n    return { client, stateUserKey };\n  };\n\n  // Start the login process by creating a signin request\n  // And redirecting the user to the returned URL\n  const loginWithRedirect = async (\n    arg: CreateSigninRequestArgs = {},\n    disableNavigation: boolean = false,\n  ): Promise<SdkResponse<URLResponse>> => {\n    const { client } = await getCachedClient();\n    const res = await client.createSigninRequest(arg);\n    const { url } = res;\n    if (!disableNavigation) {\n      window.location.href = url;\n    }\n    return { ok: true, data: res };\n  };\n\n  // Finish the login process by processing the signin response\n  // This function should be called after the user is redirected from the OIDC IdP\n  const finishLogin = async (url: string = ''): Promise<any> => {\n    const { client, stateUserKey } = await getCachedClient();\n    const res = await client.processSigninResponse(url || window.location.href);\n\n    // In order to make sure all the after-hooks are running with the success response\n    // we are generating a fake response with the success data and calling the http client after hook fn with it\n    await sdk.httpClient.hooks?.afterRequest(\n      {} as any,\n      new Response(JSON.stringify(res)),\n    );\n\n    window.localStorage.setItem(\n      stateUserKey,\n      JSON.stringify(oidcSignInResToStorage(res)),\n    );\n    // remove the code from the URL\n    removeOidcParamFromUrl();\n\n    return res;\n  };\n\n  // Finish the login process if the OIDC params are in the URL, if not, do nothing\n  // This function should be called after the user is redirected\n  // Note: high level SDKs may call this function to check if the user is in the middle of the login process\n  const finishLoginIfNeed = async (url: string = ''): Promise<any> => {\n    if (hasOidcParamsInUrl()) {\n      return await finishLogin(url);\n    }\n  };\n\n  // Start the logout process by creating a signout request\n  // And redirecting the user to the returned URL\n  const logout = async (\n    arg?: CreateSignoutRequestArgs,\n    disableNavigation: boolean = false,\n  ): Promise<any> => {\n    const { client, stateUserKey } = await getCachedClient();\n    if (!arg) {\n      arg = {};\n    }\n\n    // if id_token_hint is not provided, we will use the one from the storage\n    arg.id_token_hint = arg.id_token_hint || getIdToken();\n    arg.post_logout_redirect_uri =\n      arg.post_logout_redirect_uri || window.location.href;\n\n    const res = await client.createSignoutRequest(arg);\n    const { url } = res;\n    window.localStorage.removeItem(stateUserKey);\n    if (!disableNavigation) {\n      window.location.replace(url);\n    }\n    return res;\n  };\n\n  // Refresh the access token using the refresh token\n  const refreshToken = async (refreshToken: string) => {\n    const { client, stateUserKey } = await getCachedClient();\n\n    const user = getUserFromStorage(stateUserKey);\n    if (!user) {\n      throw new Error('User not found in storage to refresh token');\n    }\n\n    let refresh_token = refreshToken;\n    if (!refresh_token) {\n      // if refresh token is not provided, we will use the one from the hooks\n      const config = {} as RequestConfig;\n      sdk.httpClient.hooks.beforeRequest(config);\n      refresh_token = config.token;\n    }\n    const res = await client.useRefreshToken({\n      state: {\n        refresh_token,\n        session_state: user.session_state,\n        profile: user.profile,\n      },\n    });\n\n    // In order to make sure all the after-hooks are running with the success response\n    // we are generating a fake response with the success data and calling the http client after hook fn with it\n    await sdk.httpClient.hooks?.afterRequest(\n      {} as any,\n      new Response(JSON.stringify(res)),\n    );\n    return res;\n  };\n\n  return {\n    loginWithRedirect,\n    finishLogin,\n    finishLoginIfNeed,\n    refreshToken,\n    logout,\n  };\n};\n\nexport default createOidc;\nexport type { OidcConfig };\n","import { compose } from './enhancers/helpers';\nimport { withAnalytics } from './enhancers/withAnalytics';\nimport { withAutoRefresh } from './enhancers/withAutoRefresh';\nimport { withFingerprint } from './enhancers/withFingerprint';\nimport { withFlowNonce } from './enhancers/withFlowNonce';\nimport { withLastLoggedInUser } from './enhancers/withLastLoggedInUser';\nimport { withNotifications } from './enhancers/withNotifications';\nimport withPersistTokens from './enhancers/withPersistTokens';\nimport createSdk from './sdk';\n\nconst decoratedCreateSdk = compose(\n  withFingerprint,\n  withAutoRefresh,\n  withAnalytics,\n  withNotifications,\n  withFlowNonce,\n  withLastLoggedInUser, // must be one before last due to TS types\n  withPersistTokens, // must be last due to TS known limitation https://github.com/microsoft/TypeScript/issues/30727\n)(createSdk);\n\nexport type { UserResponse, OidcConfig } from './types';\n\n// Note: make sure to update ./test/umd.test.ts when adding new constants\nexport {\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './enhancers/withPersistTokens/constants';\n\nexport {\n  ensureFingerprintIds,\n  clearFingerprintData,\n} from './enhancers/withFingerprint/helpers';\n\nexport { hasOidcParamsInUrl } from './sdk/oidc/helpers';\n\nexport type { OneTapConfig } from './sdk/fedcm';\nexport type { CookieConfig } from './enhancers/withPersistTokens/types';\nexport type { FlowNonceOptions } from './enhancers/withFlowNonce/types';\nexport default decoratedCreateSdk;\n","type Fn = (arg: any) => any;\n\nexport function compose<Input, A1>(\n  fn1: (input: Input) => A1,\n): (input: Input) => A1;\n\nexport function compose<Input, A1, A2>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n): (input: Input) => A2;\n\nexport function compose<Input, A1, A2, A3>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n): (input: Input) => A3;\n\nexport function compose<Input, A1, A2, A3, A4>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n): (input: Input) => A4;\n\nexport function compose<Input, A1, A2, A3, A4, A5>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n): (input: Input) => A5;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n): (input: Input) => A6;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n): (input: Input) => A7;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n): (input: Input) => A8;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n): (input: Input) => A9;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n  fn10: (input: A9) => A10,\n): (input: Input) => A10;\n\n/**\n * Currently there is no way to create a compose function in Typescript without using overloading\n * This function currently support up to 10 wrappers\n * If needed you can add more by duplicating the type and add more parameters\n */\n\nexport function compose(...args: Fn[]) {\n  return (data: any) => args.reduce((acc, elem) => elem(acc), data) as any;\n}\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse, isDescopeBridge } from '../helpers';\nimport {\n  createTimerFunctions,\n  getTokenExpiration,\n  getAutoRefreshTimeout,\n} from './helpers';\nimport { AutoRefreshOptions } from './types';\nimport logger from '../helpers/logger';\nimport { IS_BROWSER, REFRESH_THRESHOLD } from '../../constants';\nimport { getRefreshToken } from '../withPersistTokens/helpers';\n\n/**\n * Automatically refresh the session token before it expires\n * It uses the the refresh token that is extracted from API response to do that\n */\nexport const withAutoRefresh =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ autoRefresh, ...config }: Parameters<T>[0] & AutoRefreshOptions) => {\n    if (!autoRefresh || isDescopeBridge()) return createSdk(config);\n\n    // if we hold a single timer id, there might be a case where we override it before canceling the timer, this might cause many calls to refresh\n    // in order to prevent it, we hold a list of timers and cancel all of them when a new timer is set, which means we should have one active timer only at a time\n    const { clearAllTimers, setTimer } = createTimerFunctions();\n\n    // we need to hold the expiration time and the refresh token in order to refresh the session\n    // when the user comes back to the tab or from background/lock screen/etc.\n    let sessionExpirationDate: Date;\n    let refreshToken: string;\n    if (IS_BROWSER) {\n      document.addEventListener('visibilitychange', () => {\n        // tab becomes visible and the session is expired, do a refresh\n        if (\n          document.visibilityState === 'visible' &&\n          sessionExpirationDate &&\n          new Date() > sessionExpirationDate\n        ) {\n          logger.debug('Expiration time passed, refreshing session');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshToken);\n        }\n      });\n    }\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const { sessionJwt, refreshJwt, sessionExpiration } =\n        await getAuthInfoFromResponse(res);\n\n      // if we got 401 we want to cancel all timers\n      if (res?.status === 401) {\n        logger.debug('Received 401, canceling all timers');\n        clearAllTimers();\n      } else if (sessionJwt || sessionExpiration) {\n        sessionExpirationDate = getTokenExpiration(\n          sessionJwt,\n          sessionExpiration,\n        );\n        if (!sessionExpirationDate) {\n          logger.debug('Could not extract expiration time from session token');\n          return;\n        }\n        refreshToken = refreshJwt;\n        const timeout = getAutoRefreshTimeout(sessionExpirationDate);\n        clearAllTimers();\n\n        if (timeout <= REFRESH_THRESHOLD) {\n          /*\n            When receiving a session with very short expiration - it means that the refresh token is also close to expiration\n            This happens because session expiration cannot be more than the refresh expiration\n            In this case - the user is going to be logged out soon, so we don't want to set a refresh timer\n          */\n          logger.debug(\n            'Session is too close to expiration, not setting refresh timer',\n          );\n          return;\n        }\n\n        const refreshTimeStr = new Date(\n          Date.now() + timeout,\n        ).toLocaleTimeString('en-US', { hour12: false });\n        logger.debug(\n          `Setting refresh timer for ${refreshTimeStr}. (${timeout}ms)`,\n        );\n\n        setTimer(() => {\n          logger.debug('Refreshing session due to timer');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshJwt);\n        }, timeout);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n        logger.debug('Clearing all timers');\n        clearAllTimers();\n\n        return resp;\n      };\n\n    return wrapWith(sdk, ['logout', 'logoutAll', 'oidc.logout'], wrapper);\n  };\n","import { CreateWebSdk } from '../sdk';\nimport { BeforeRequestHook } from '../types';\nimport { addHooks } from './helpers';\n\n// this is replaced in build time\ndeclare const BUILD_VERSION: string;\n/**\n * Adds analytics headers to requests\n */\nexport const withAnalytics =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) =>\n    createSdk({\n      ...config,\n      baseHeaders: {\n        'x-descope-sdk-name': 'web-js',\n        'x-descope-sdk-version': BUILD_VERSION,\n        ...config.baseHeaders,\n      },\n    });\n","import { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport {\n  FLOW_NEXT_PATH,\n  FLOW_NONCE_HEADER,\n  FLOW_NONCE_PREFIX,\n  FLOW_START_PATH,\n} from './constants';\nimport {\n  cleanupExpiredNonces,\n  extractFlowNonce,\n  getExecutionIdFromRequest,\n  getFlowNonce,\n  setFlowNonce,\n} from './helpers';\nimport { FlowNonceOptions } from './types';\n\n/**\n * Adds flow nonce handling to the SDK\n */\nexport const withFlowNonce =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0] & FlowNonceOptions): ReturnType<T> => {\n    const {\n      enableFlowNonce = true,\n      nonceStoragePrefix = FLOW_NONCE_PREFIX,\n      ...sdkConfig\n    } = config;\n\n    if (!enableFlowNonce) {\n      return createSdk(sdkConfig) as ReturnType<T>;\n    }\n\n    cleanupExpiredNonces(nonceStoragePrefix);\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      if (req.path !== FLOW_START_PATH && req.path !== FLOW_NEXT_PATH) {\n        return;\n      }\n      const { nonce, executionId } = await extractFlowNonce(req, res);\n\n      if (nonce && executionId) {\n        const isStart = req.path === FLOW_START_PATH;\n        setFlowNonce(executionId, nonce, isStart, nonceStoragePrefix);\n      }\n    };\n\n    const beforeRequest: BeforeRequestHook = (req) => {\n      if (req.path === FLOW_NEXT_PATH) {\n        const executionId = getExecutionIdFromRequest(req);\n\n        if (executionId) {\n          const nonce = getFlowNonce(executionId, nonceStoragePrefix);\n          if (nonce) {\n            req.headers = req.headers || {};\n            req.headers[FLOW_NONCE_HEADER] = nonce;\n          }\n        }\n      }\n      return req;\n    };\n\n    return createSdk(\n      addHooks(sdkConfig, { afterRequest, beforeRequest }),\n    ) as ReturnType<T>;\n  };\n\nexport * from './helpers';\nexport * from './types';\nexport * from './constants';\n","import createCoreSdk, { SdkResponse } from '@descope/core-js-sdk';\nimport createWebAuthn from './webauthn';\nimport createFedCM from './fedcm';\nimport withFlow from './flow';\nimport {\n  getSessionToken,\n  getRefreshToken,\n} from '../enhancers/withPersistTokens/helpers';\nimport createOidc from './oidc';\nimport { CoreSdk, WebSdkConfig } from '../types';\nimport { OIDC_LOGOUT_ERROR_CODE, OIDC_REFRESH_ERROR_CODE } from '../constants';\nimport logger from '../enhancers/helpers/logger';\n\nconst createSdk = (config: WebSdkConfig) => {\n  const coreSdk = createCoreSdk(config);\n\n  const oidc = createOidc(coreSdk, config.projectId, config.oidcConfig);\n\n  return {\n    ...coreSdk,\n    refresh: async (\n      token?: string,\n      tryRefresh?: boolean,\n    ): ReturnType<CoreSdk['refresh']> => {\n      if (config.oidcConfig) {\n        try {\n          await oidc.refreshToken(token);\n          return Promise.resolve({ ok: true });\n        } catch (error) {\n          return Promise.resolve({\n            ok: false,\n            error: {\n              errorCode: OIDC_REFRESH_ERROR_CODE,\n              errorDescription: error.toString(),\n            },\n          });\n        }\n      }\n      // Descope use this query param to monitor if refresh is made\n      // When the user is already logged in in the past or not (We want to optimize that in the future)\n      const currentSessionToken = getSessionToken();\n      const currentRefreshToken = getRefreshToken();\n\n      let externalToken = '';\n      if (config.getExternalToken) {\n        try {\n          externalToken = await config.getExternalToken?.();\n        } catch (error) {\n          logger.debug('Error getting external token while refreshing', error);\n          // continue without external token\n        }\n      }\n\n      return coreSdk.refresh(\n        token,\n        {\n          dcs: currentSessionToken ? 't' : 'f',\n          dcr: currentRefreshToken ? 't' : 'f',\n        },\n        externalToken,\n        tryRefresh,\n      );\n    },\n    // Call the logout function according to the oidcConfig\n    // And return the response in the same format\n    logout: async (token?: string): Promise<SdkResponse<never>> => {\n      if (config.oidcConfig) {\n        // logout is made with id_token_hint\n        try {\n          await oidc.logout({ id_token_hint: token });\n          return Promise.resolve({ ok: true });\n        } catch (error) {\n          return Promise.resolve({\n            ok: false,\n            error: {\n              errorCode: OIDC_LOGOUT_ERROR_CODE,\n              errorDescription: error.toString(),\n            },\n          });\n        }\n      }\n      return coreSdk.logout(token);\n    },\n    flow: withFlow(coreSdk),\n    webauthn: createWebAuthn(coreSdk),\n    fedcm: createFedCM(coreSdk, config.projectId),\n    oidc,\n  };\n};\n\nexport default createSdk;\n\nexport type CreateWebSdk = typeof createSdk;\nexport type WebSdk = ReturnType<CreateWebSdk>;\n"],"names":["getExpirationFromToken","token","jwtDecode","exp","e","oidcRefreshTokenExpiration","response","refresh_expire_in","refresh_token","Math","floor","Date","now","oidcAccessTokenExpiration","expires_in","expires_at","access_token","addHooks","config","hooks","reduce","acc","key","concat","_a","getAuthInfoFromResponse","async","res","ok","body","clone","json","id_token","rest","__rest","Object","assign","sessionJwt","idToken","refreshJwt","sessionExpiration","cookieExpiration","normalizeWebJWTResponseToJWTResponse","authInfo","getUserFromResponse","user","hasOwnProperty","undefined","isLocalStorage","localStorage","setLocalStorage","value","setItem","getLocalStorage","getItem","removeLocalStorage","removeItem","logger","args","console","debug","OIDC_CLIENT_TS_VERSION","IS_BROWSER","window","MAX_TIMEOUT","pow","OIDC_CLIENT_TS_DESCOPE_CDN_URL","OIDC_CLIENT_TS_JSDELIVR_CDN_URL","getAutoRefreshTimeout","timeout","date","getTime","SESSION_TOKEN_KEY","REFRESH_TOKEN_KEY","ID_TOKEN_KEY","setJwtTokenCookie","name","cookieDomain","cookiePath","cookieSameSite","cookieSecure","expires","domainMatches","currentDomainParts","location","hostname","split","cookieDomainParts","slice","length","join","isCurrentDomainOrParentDomain","Cookies","set","path","domain","sameSite","secure","getRefreshToken","prefix","getSessionToken","default","get","getIdToken","clearTokens","remove","FP_EP_URL","VISITOR_SESSION_ID_PARAM","VISITOR_REQUEST_ID_PARAM","FP_STORAGE_KEY","getFPFromStorage","returnExpired","itemStr","item","JSON","parse","expiry","ensureFingerprintIds","fpKey","baseUrl","sessionId","toString","random","substring","endpointUrl","URL","pathname","patterUrl","scriptUrlPattern","agentP","load","apiKey","endpoint","defaultEndpoint","defaultScriptUrlPattern","agent","requestId","linkedId","fpData","createFingerprintObject","stringify","setFPToStorage","ex","warn","beforeRequest","data","FLOW_NONCE_PREFIX","FLOW_NONCE_HEADER","FLOW_START_PATH","FLOW_NEXT_PATH","getNonceKeyForExecution","executionId","removeFlowNonce","error","extractExecId","exec","getExecutionIdFromRequest","req","LOCAL_STORAGE_LAST_USER_LOGIN_ID","LOCAL_STORAGE_LAST_USER_DISPLAY_NAME","getLastUserLoginId","getLastUserDisplayName","startWrapper","fn","options","loginId","displayName","lastAuth","logoutWrapper","keepOnLogout","resp","createPubSub","cbs","pub","forEach","cb","sub","idx","push","splice","wrapper","create","createOptions","publicKey","challenge","decodeBase64Url","id","excludeCredentials","decodeCreateOptions","createResponse","navigator","credentials","credential","rawId","encodeBase64Url","type","attestationObject","clientDataJSON","getOptions","decodeGetOptions","encodeGetResponse","conditional","abort","signal","mediation","isSupported","requirePlatformAuthenticator","Promise","resolve","supported","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","allowCredentials","authenticatorData","signature","userHandle","base64","replace","Uint8Array","from","atob","c","charCodeAt","buffer","btoa","String","fromCharCode","apply","creator","createWebAuthn$1","sdk","signUp","identifier","passkeyOptions","startResponse","webauthn","start","origin","finish","transactionId","signIn","getResponse","signUpOrIn","update","helpers","obj","apiPaths","generateNonce","crypto","getRandomValues","array","Array","byte","padStart","performOneTap","performOneTapAsync","onFailed","call","auth","provider","oneTapConfig","onSkipped","onDismissed","nonce","googleClient","reject","google","accounts","googleScript","document","getElementById","createElement","head","appendChild","defer","src","onload","onerror","getGoogleClient","clientIdRes","oauth","getOneTapClientId","Error","clientId","callback","initialize","itp_support","use_fedcm_for_prompt","_b","client_id","prompt","notification","isDismissedMoment","reason","getDismissedReason","isSkippedMoment","getSkippedReason","startOneTap","onCodeReceived","verifyOneTapIDToken","loginOptions","code","exchangeOneTapIDToken","onAuthenticated","withFlow","coreSdk","flow","webAuthnSupport","decoratedOptions","href","deviceInfo","startOptionsVersion","hasOidcParamsInUrl","search","includes","scriptLoadingPromise","loadScriptWithFallback","urls","getEntry","entry","url","shift","scriptEle","input","hash","i","abs","simpleHash","addEventListener","setAttribute","getOidcClient","projectId","oidcConfig","require","loadOIDCModule","OidcClient","WebStorageStateStore","redirectUri","scope","stateUserKey","authority","httpClient","buildUrl","applicationId","settings","redirect_uri","response_type","stateStore","store","loadUserInfo","fetchRequestCredentials","client","createOidc","getCachedClient","finishLogin","processSigninResponse","signInRes","afterRequest","Response","session_state","profile","currentUrl","searchParams","delete","history","replaceState","title","removeOidcParamFromUrl","loginWithRedirect","arg","disableNavigation","createSigninRequest","finishLoginIfNeed","refreshToken","getUserFromStorage","useRefreshToken","state","logout","id_token_hint","post_logout_redirect_uri","createSignoutRequest","decoratedCreateSdk","elem","compose","createSdk","fpLoad","catch","autoRefresh","clearAllTimers","setTimer","timerIds","clearTimeout","pop","setTimeout","createTimerFunctions","sessionExpirationDate","visibilityState","refresh","_req","status","claims","getTokenExpiration","refreshTimeStr","toLocaleTimeString","hour12","wrapWith","baseHeaders","sessionExpirationPS","sessionPS","userPS","userDetails","wrappedSdk","onSessionTokenChange","onUserChange","onIsAuthenticatedChange","enableFlowNonce","nonceStoragePrefix","sdkConfig","startsWith","parseError","cleanupExpiredNonces","headers","then","extractFlowNonce","isStart","ttlSeconds","setFlowNonce","getFlowNonce","storeLastAuthenticatedUser","keepLastAuthenticatedUserAfterLogout","loginIds","setLastUserLoginId","setLastUserDisplayName","persistTokens","isPersistTokens","sessionTokenViaCookie","storagePrefix","isManagementApi","test","createCoreSdk","oidc","tryRefresh","errorCode","errorDescription","currentSessionToken","currentRefreshToken","externalToken","getExternalToken","dcs","dcr","createWebAuthn","fedcm","onetap","requestExchangeCode","requestAuthentication","oneTap","launch","context","identity","providers","configURL","isLoggedIn"],"mappings":"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"}