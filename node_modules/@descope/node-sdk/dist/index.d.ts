import * as _descope_core_js_sdk from '@descope/core-js-sdk';
import _descope_core_js_sdk__default, { DeliveryMethod, UserResponse, LoginOptions, SdkResponse, JWTResponse, AccessKeyLoginOptions, ExchangeAccessKeyResponse } from '@descope/core-js-sdk';
export { DeliveryMethod, JWTResponse, OAuthProvider, ResponseData, SdkResponse } from '@descope/core-js-sdk';
import { JWTHeaderParameters, KeyLike } from 'jose';

/** Parsed JWT token */
interface Token {
    sub?: string;
    exp?: number;
    iss?: string;
    [claim: string]: unknown;
}
/** All information regarding token including the raw JWT, parsed JWT and cookies */
interface AuthenticationInfo {
    jwt: string;
    token: Token;
    cookies?: string[];
}
interface RefreshAuthenticationInfo extends AuthenticationInfo {
    refreshJwt?: string;
}
declare type DeliveryMethodForTestUser = DeliveryMethod | 'Embedded';

declare type ExpirationUnit = 'minutes' | 'hours' | 'days' | 'weeks';
/**
 * Represents a tenant association for a User or Access Key. The tenantId is required to denote
 * which tenant the user or access key belongs to. The roleNames array is an optional list of
 * roles for the user or access key in this specific tenant.
 */
declare type AssociatedTenant = {
    tenantId: string;
    roleNames: string[];
};
/** The tenantId of a newly created tenant */
declare type CreateTenantResponse = {
    id: string;
};
declare type GenerateSSOConfigurationLinkResponse = {
    adminSSOConfigurationLink: string;
};
/**
 * Options to create or update an OIDC application.
 *
 * **Note:** When updating, `id` will be required to perform the operation
 */
declare type OidcApplicationOptions = {
    name: string;
    loginPageUrl: string;
    id?: string;
    description?: string;
    logo?: string;
    enabled?: boolean;
    forceAuthentication?: boolean;
};
/**
 * Options to create or update a SAML application.
 *
 * **Note:** When updating, `id` will be required to perform the operation
 */
declare type SamlApplicationOptions = {
    name: string;
    loginPageUrl: string;
    id?: string;
    description?: string;
    logo?: string;
    enabled?: boolean;
    useMetadataInfo?: boolean;
    metadataUrl?: string;
    entityId?: string;
    acsUrl?: string;
    certificate?: string;
    attributeMapping?: SamlIdpAttributeMappingInfo[];
    groupsMapping?: SamlIdpGroupsMappingInfo[];
    acsAllowedCallbacks?: string[];
    subjectNameIdType?: string;
    subjectNameIdFormat?: string;
    defaultRelayState?: string;
    forceAuthentication?: boolean;
    logoutRedirectUrl?: string;
};
/**
 * Represents a SAML IDP attribute mapping object. Use this class for mapping Descope attribute
 * to the relevant SAML Assertion attributes matching your expected SP attributes names.
 */
declare type SamlIdpAttributeMappingInfo = {
    name: string;
    type: string;
    value: string;
};
/** Represents a SAML IDP Role Group mapping object. */
declare type SAMLIDPRoleGroupMappingInfo = {
    id: string;
    name: string;
};
/**
 * Represents a SAML IDP groups mapping object. Use this class for mapping Descope roles
 * to the relevant SAML Assertion groups attributes that matching your expected SP groups attributes names.
 */
declare type SamlIdpGroupsMappingInfo = {
    name: string;
    type: string;
    filterType: string;
    value: string;
    roles: SAMLIDPRoleGroupMappingInfo[];
};
/** The ID of a newly created SSO application */
declare type CreateSSOApplicationResponse = {
    id: string;
};
/** An access key that can be used to access descope */
declare type AccessKey = {
    id: string;
    name: string;
    expiredTime: number;
    roleNames: string[];
    keyTenants?: AssociatedTenant[];
    status: string;
    createdTime: number;
    expiresTime: number;
    createdBy: string;
    clientId: string;
    boundUserId?: string;
    description?: string;
    permittedIps?: string[];
};
/** Access Key extended details including created key cleartext */
declare type CreatedAccessKeyResponse = {
    key: AccessKey;
    cleartext: string;
};
/** Represents a mapping between a set of groups of users and a role that will be assigned to them */
declare type RoleMapping = {
    groups: string[];
    roleName: string;
};
declare type RoleMappings = RoleMapping[];
/** Represents a mapping between Descope and IDP user attributes */
declare type AttributeMapping = {
    name?: string;
    email?: string;
    username?: string;
    phoneNumber?: string;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    picture?: string;
    verifiedEmail?: string;
    verifiedPhone?: string;
    group?: string;
    customAttributes?: Record<string, string>;
};
/** UpdateJWT response with a new JWT value with the added custom claims */
declare type UpdateJWTResponse = {
    jwt: string;
};
/** Represents a tenant in a project. It has an id, a name and an array of
 * self provisioning domains used to associate users with that tenant.
 */
declare type Tenant = {
    id: string;
    name: string;
    selfProvisioningDomains: string[];
    createdTime: number;
    customAttributes?: Record<string, string | number | boolean | string[]>;
    domains?: string[];
    authType?: 'none' | 'saml' | 'oidc';
    enforceSSO?: boolean;
    disabled?: boolean;
};
/** Represents settings of a tenant in a project. It has an id, a name and an array of
 * self provisioning domains used to associate users with that tenant.
 */
declare type TenantSettings = {
    selfProvisioningDomains: string[];
    domains?: string[];
    authType?: 'none' | 'saml' | 'oidc';
    sessionSettingsEnabled?: boolean;
    refreshTokenExpiration?: number;
    refreshTokenExpirationUnit?: ExpirationUnit;
    sessionTokenExpiration?: number;
    sessionTokenExpirationUnit?: ExpirationUnit;
    stepupTokenExpiration?: number;
    stepupTokenExpirationUnit?: ExpirationUnit;
    enableInactivity?: boolean;
    InactivityTime?: number;
    InactivityTimeUnit?: ExpirationUnit;
    JITDisabled?: boolean;
};
/** Represents password settings of a tenant in a project. It has the password policy details. */
declare type PasswordSettings = {
    enabled: boolean;
    minLength: number;
    lowercase: boolean;
    uppercase: boolean;
    number: boolean;
    nonAlphaNumeric: boolean;
    expiration: boolean;
    expirationWeeks: number;
    reuse: boolean;
    reuseAmount: number;
    lock: boolean;
    lockAttempts: number;
};
/** Represents OIDC settings of an SSO application in a project. */
declare type SSOApplicationOIDCSettings = {
    loginPageUrl: string;
    issuer: string;
    discoveryUrl: string;
    forceAuthentication: boolean;
};
/** Represents SAML settings of an SSO application in a project. */
declare type SSOApplicationSAMLSettings = {
    loginPageUrl: string;
    idpCert: string;
    useMetadataInfo: boolean;
    metadataUrl: string;
    entityId: string;
    acsUrl: string;
    certificate: string;
    attributeMapping: SamlIdpAttributeMappingInfo[];
    groupsMapping: SamlIdpGroupsMappingInfo[];
    idpMetadataUrl: string;
    idpEntityId: string;
    idpSsoUrl: string;
    acsAllowedCallbacks: string[];
    subjectNameIdType: string;
    subjectNameIdFormat: string;
    defaultRelayState: string;
    forceAuthentication: boolean;
    idpLogoutUrl: string;
    logoutRedirectUrl: string;
};
/** Represents an SSO application in a project. */
declare type SSOApplication = {
    id: string;
    name: string;
    description: string;
    enabled: boolean;
    logo: string;
    appType: string;
    samlSettings: SSOApplicationSAMLSettings;
    oidcSettings: SSOApplicationOIDCSettings;
};
/** Represents a permission in a project. It has a name and optionally a description.
 * It also has a flag indicating whether it is system default or not.
 */
declare type Permission = {
    name: string;
    description?: string;
    systemDefault: boolean;
};
/** Represents a role in a project. It has a name and optionally a description and
 * a list of permissions it grants.
 */
declare type Role = {
    name: string;
    description?: string;
    permissionNames: string[];
    createdTime: number;
    tenantId?: string;
    default?: boolean;
};
/** Search roles based on the parameters */
declare type RoleSearchOptions = {
    tenantIds?: string[];
    roleNames?: string[];
    roleNameLike?: string;
    permissionNames?: string[];
    includeProjectRoles?: boolean;
};
/** Represents a group in a project. It has an id and display name and a list of group members. */
declare type Group = {
    id: string;
    display: string;
    members?: GroupMember[];
};
/** Represents a group member. It has loginId, userId and display. */
declare type GroupMember = {
    loginId: string;
    userId: string;
    display: string;
};
declare type Flow = {
    id: string;
    name: string;
    description?: string;
    dsl: any;
    disabled: boolean;
    etag?: string;
};
declare type FlowMetadata = {
    id: string;
    name: string;
    description?: string;
    disabled: boolean;
};
declare type Screen = {
    id: string;
    flowId: string;
    inputs?: any;
    interactions?: any;
    htmlTemplate: any;
};
declare type FlowsResponse = {
    flows: FlowMetadata[];
    total: number;
};
declare type FlowResponse = {
    flow: Flow;
    screens: Screen[];
};
declare type Theme = {
    id: string;
    cssTemplate?: any;
};
declare type ThemeResponse = {
    theme: Theme;
};
declare type GenerateOTPForTestResponse = {
    loginId: string;
    code: string;
};
declare type GenerateMagicLinkForTestResponse = {
    loginId: string;
    link: string;
};
declare type GenerateEnchantedLinkForTestResponse = {
    loginId: string;
    link: string;
    pendingRef: string;
};
declare type GenerateEmbeddedLinkResponse = {
    token: string;
};
declare type AttributesTypes = string | boolean | number | string[];
declare type TemplateOptions = Record<string, string>;
declare type User = {
    loginId: string;
    email?: string;
    phone?: string;
    displayName?: string;
    roles?: string[];
    userTenants?: AssociatedTenant[];
    customAttributes?: Record<string, AttributesTypes>;
    picture?: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    test?: boolean;
    additionalLoginIds?: string[];
    password?: string;
    hashedPassword?: UserPasswordHashed;
    seed?: string;
    status?: UserStatus;
    createdTime?: number;
};
declare type UserPasswordHashed = {
    bcrypt?: UserPasswordBcrypt;
    pbkdf2?: UserPasswordPbkdf2;
    firebase?: UserPasswordFirebase;
    django?: UserPasswordDjango;
    phpass?: UserPasswordPhpass;
    md5?: UserPasswordMd5;
};
declare type UserPasswordBcrypt = {
    hash: string;
};
declare type UserPasswordPbkdf2 = {
    hash: string;
    salt: string;
    iterations: number;
    type: 'sha1' | 'sha256' | 'sha512';
};
declare type UserPasswordFirebase = {
    hash: string;
    salt: string;
    saltSeparator: string;
    signerKey: string;
    memory: number;
    rounds: number;
};
declare type UserPasswordDjango = {
    hash: string;
};
declare type UserPasswordPhpass = {
    hash: string;
    salt: string;
    iterations: number;
    type: 'md5' | 'sha512';
};
declare type UserPasswordMd5 = {
    hash: string;
};
declare type UserMapping = {
    name: string;
    email: string;
    username: string;
    phoneNumber: string;
};
declare type RoleItem = {
    id: string;
    name: string;
};
declare type GroupsMapping = {
    role: RoleItem;
    groups: string[];
};
declare type SSOSettingsResponse = {
    tenantId: string;
    idpEntityId: string;
    idpSSOUrl: string;
    idpCertificate: string;
    idpMetadataUrl: string;
    spEntityId: string;
    spACSUrl: string;
    spCertificate: string;
    userMapping: UserMapping;
    groupsMapping: GroupsMapping[];
    redirectUrl: string;
    domains: string[];
    domain: string;
};
declare type SSOSAMLSettingsResponse = {
    idpEntityId: string;
    idpSSOUrl: string;
    idpCertificate: string;
    idpMetadataUrl: string;
    spEntityId: string;
    spACSUrl: string;
    spCertificate: string;
    attributeMapping: AttributeMapping;
    groupsMapping: RoleMappings;
    defaultSSORoles: string[];
    redirectUrl: string;
};
declare type SSOSettings = {
    tenant: Tenant;
    saml?: SSOSAMLSettingsResponse;
    oidc?: SSOOIDCSettings;
    ssoId?: string;
};
declare type OIDCAttributeMapping = {
    loginId?: string;
    name?: string;
    email?: string;
    username?: string;
    phoneNumber?: string;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    picture?: string;
    verifiedEmail?: string;
    verifiedPhone?: string;
    customAttributes?: Record<string, string>;
};
declare type Prompt = 'none' | 'login' | 'consent' | 'select_account';
declare type SSOOIDCSettings = {
    name: string;
    clientId: string;
    clientSecret?: string;
    redirectUrl?: string;
    authUrl?: string;
    tokenUrl?: string;
    userDataUrl?: string;
    scope?: string[];
    JWKsUrl?: string;
    attributeMapping?: OIDCAttributeMapping;
    manageProviderTokens?: boolean;
    callbackDomain?: string;
    prompt?: Prompt[];
    grantType?: 'authorization_code' | 'implicit';
    issuer?: string;
};
declare type SSOSAMLSettings = {
    idpUrl: string;
    idpCert: string;
    entityId: string;
    roleMappings?: RoleMappings;
    attributeMapping?: AttributeMapping;
    defaultSSORoles?: string[];
    spACSUrl?: string;
    spEntityId?: string;
};
declare type SSOSAMLByMetadataSettings = {
    idpMetadataUrl: string;
    roleMappings?: RoleMappings;
    attributeMapping?: AttributeMapping;
    defaultSSORoles?: string[];
    spACSUrl?: string;
    spEntityId?: string;
};
declare type ProviderTokenOptions = {
    withRefreshToken?: boolean;
    forceRefresh?: boolean;
};
declare type ProviderTokenResponse = {
    provider: string;
    providerUserId: string;
    accessToken: string;
    expiration: number;
    scopes: string[];
};
declare type UserFailedResponse = {
    failure: string;
    user: UserResponse;
};
declare type CreateOrInviteBatchResponse = {
    createdUsers: UserResponse[];
    failedUsers: UserFailedResponse[];
    additionalErrors: Record<string, string>;
};
/**
 * Search options to filter which audit records we should retrieve.
 * All parameters are optional. `From` is currently limited to 30 days.
 */
declare type AuditSearchOptions = {
    userIds?: string[];
    actions?: string[];
    excludedActions?: string[];
    devices?: string[];
    methods?: string[];
    geos?: string[];
    remoteAddresses?: string[];
    loginIds?: string[];
    tenants?: string[];
    noTenants?: boolean;
    text?: string;
    from?: number;
    to?: number;
};
declare type AuditType = 'info' | 'warn' | 'error';
/** Audit create options for creating audit event */
declare type AuditCreateOptions = {
    userId?: string;
    action: string;
    type: AuditType;
    actorId: string;
    tenantId: string;
    data?: Record<string, any>;
};
/** Audit record response from the audit trail. Occurred is in milliseconds. */
declare type AuditRecord = {
    projectId: string;
    userId: string;
    action: string;
    occurred: number;
    device: string;
    method: string;
    geo: string;
    remoteAddress: string;
    loginIds: string[];
    tenants: string[];
    data: Record<string, any>;
};
declare type UserStatus = 'enabled' | 'disabled' | 'invited';
declare type AuthzNodeExpressionType = 'self' | 'targetSet' | 'relationLeft' | 'relationRight';
/**
 * AuthzNodeExpression holds the definition of a child node
 */
declare type AuthzNodeExpression = {
    neType: AuthzNodeExpressionType;
    relationDefinition?: string;
    relationDefinitionNamespace?: string;
    targetRelationDefinition?: string;
    targetRelationDefinitionNamespace?: string;
};
declare type AuthzNodeType = 'child' | 'union' | 'intersect' | 'sub';
/**
 * AuthzNode holds the definition of a complex relation definition
 */
declare type AuthzNode = {
    nType: AuthzNodeType;
    children?: AuthzNode[];
    expression?: AuthzNodeExpression;
};
/**
 * AuthzRelationDefinition defines a relation within a namespace
 */
declare type AuthzRelationDefinition = {
    name: string;
    complexDefinition?: AuthzNode;
};
/**
 * AuthzNamespace defines an entity in the authorization schema
 */
declare type AuthzNamespace = {
    name: string;
    relationDefinitions: AuthzRelationDefinition[];
};
/**
 * AuthzSchema holds the full schema (all namespaces) for a project
 */
declare type AuthzSchema = {
    name?: string;
    namespaces: AuthzNamespace[];
};
/**
 * AuthzUserQuery represents a target of a relation for ABAC (query on users)
 */
declare type AuthzUserQuery = {
    tenants?: string[];
    roles?: string[];
    text?: string;
    statuses?: UserStatus[];
    ssoOnly?: boolean;
    withTestUser?: boolean;
    customAttributes?: Record<string, any>;
};
declare type AuthzResource = {
    resource: string;
};
/**
 * AuthzRelation defines a relation between resource and target
 */
declare type AuthzRelation = {
    resource: string;
    relationDefinition: string;
    namespace: string;
    target?: string;
    targetSetResource?: string;
    targetSetRelationDefinition?: string;
    targetSetRelationDefinitionNamespace?: string;
    query?: AuthzUserQuery;
};
/**
 * AuthzRelationQuery queries the service if a given relation exists
 */
declare type AuthzRelationQuery = {
    resource: string;
    relationDefinition: string;
    namespace: string;
    target: string;
    hasRelation?: boolean;
};
/**
 * AuthzModified has the list of resources and targets that were modified since given time returned from GetModified
 */
declare type AuthzModified = {
    resources: string[];
    targets: string[];
    schemaChanged: boolean;
};
declare type ExportSnapshotResponse = {
    /** All project settings and configurations represented as JSON files */
    files: Record<string, any>;
};
declare type ImportSnapshotRequest = {
    /** All project settings and configurations represented as JSON files */
    files: Record<string, any>;
    /**
     * An optional map of project entities and their secrets that will be
     * injected into the snapshot before import (see below)
     */
    inputSecrets?: SnapshotSecrets;
};
declare type ValidateSnapshotRequest = {
    /** All project settings and configurations represented as JSON files */
    files: Record<string, any>;
    /**
     * An optional map of project entities and their secrets that will be
     * injected into the snapshot before validation (see below)
     */
    inputSecrets?: SnapshotSecrets;
};
declare type ValidateSnapshotResponse = {
    /** Whether the validation passed or not (true if and only if `failures` is empty) */
    ok: boolean;
    /** An array with `string` representations of any validation failures that were found */
    failures?: string[];
    /**
     * An optional object that lists which if any secret values need to be provided in
     * the request for an `importSnapshot` call so it doesn't fail (see below)
     */
    missingSecrets?: SnapshotSecrets;
};
declare type SnapshotSecrets = {
    /** Any missing or input secrets for connectors in a snapshot */
    connectors?: SnapshotSecret[];
    /** Any missing or input secrets for OAuth providers in a snapshot */
    oauthProviders?: SnapshotSecret[];
};
declare type SnapshotSecret = {
    /** The id of the project entity that requires this secret */
    id: string;
    /** The name of the project entity that requires this secret */
    name: string;
    /** The type of secret, e.g., "bearertoken", "password" */
    type: string;
    /**
     * The cleartext value of the secret. This value must not be empty when used in
     * request objects when calling ValidateSnapshot and ImportSnapshot. Conversely,
     * this value is an empty string when returned in ValidateSnapshotResponse to
     * signify that this is a missing secret.
     */
    value: string;
};
declare type CloneProjectResponse = {
    projectId: string;
    projectName: string;
    environment?: string;
    tags?: string[];
};
declare type Project = {
    id: string;
    name: string;
    environment?: string;
    tags?: string[];
};
declare type FGASchema = {
    dsl: string;
};
declare type FGARelation = {
    resource: string;
    resourceType?: string;
    relation: string;
    target: string;
    targetType?: string;
};
declare type CheckResponseRelation = {
    allowed: boolean;
    tuple: FGARelation;
};
interface FGAResourceIdentifier {
    resourceId: string;
    resourceType: string;
}
interface FGAResourceDetails {
    resourceId: string;
    resourceType: string;
    displayName: string;
}
declare type MgmtLoginOptions = Omit<LoginOptions, 'templateId' | 'templateOptions'> & {
    jwt?: string;
    refreshDuration?: number;
};
declare type MgmtSignUpOptions = {
    customClaims?: Record<string, any>;
    refreshDuration?: number;
};
interface UserOptions {
    email?: string;
    phone?: string;
    displayName?: string;
    roles?: string[];
    userTenants?: AssociatedTenant[];
    customAttributes?: Record<string, AttributesTypes>;
    picture?: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    additionalLoginIds?: string[];
    ssoAppIds?: string[];
}
declare type MgmtUserOptions = Omit<UserOptions, 'roles' | 'userTenants' | 'customAttributes' | 'picture' | 'additionalLoginIds' | 'displayName'> & {
    name?: string;
};
declare type InboundApplicationScope = {
    name: string;
    description: string;
    values?: string[];
    optional?: boolean;
};
/**
 * Represents an inbound application request in a project.
 * This type is used to create a new inbound application in a project.
 */
declare type InboundApplicationOptions = {
    name: string;
    description?: string;
    logo?: string;
    loginPageUrl?: string;
    approvedCallbackUrls?: string[];
    permissionsScopes: InboundApplicationScope[];
    attributesScopes?: InboundApplicationScope[];
};
/**
 * Represents an inbound application in a project.
 */
declare type InboundApplication = InboundApplicationOptions & {
    id: string;
    clientId: string;
};
declare type InboundApplicationSecretResponse = {
    cleartext: string;
};
declare type CreateInboundApplicationResponse = {
    id: string;
    clientId: string;
} & InboundApplicationSecretResponse;
/**
 * Represents an inbound application consent for a single application
 * for a specific user within the project.
 */
declare type InboundApplicationConsent = {
    id: string;
    appId: string;
    userId: string;
    scopes: string[];
    grantedBy: string;
    createdTime: number;
};
declare type InboundApplicationConsentSearchOptions = {
    appId?: string;
    userId?: string;
    consentId?: string;
    page?: number;
};
declare type InboundApplicationConsentDeleteOptions = {
    consentIds?: string[];
    appId?: string;
    userIds?: string[];
};
declare type PromptType = 'none' | 'login' | 'consent' | 'select_account';
declare type AccessType = 'offline' | 'online';
declare type OutboundApplication = {
    id: string;
    name: string;
    description?: string;
    clientId?: string;
    logo?: string;
    discoveryUrl?: string;
    authorizationUrl?: string;
    authorizationUrlParams?: URLParam[];
    tokenUrl?: string;
    tokenUrlParams?: URLParam[];
    revocationUrl?: string;
    defaultScopes?: string[];
    defaultRedirectUrl?: string;
    callbackDomain?: string;
    pkce?: boolean;
    accessType?: AccessType;
    prompt?: Array<PromptType>;
};
declare type URLParam = {
    key: string;
    value: string;
};
declare type FetchOutboundAppTokenOptions = {
    withRefreshToken?: boolean;
    forceRefresh?: boolean;
};
declare type OutboundAppToken = {
    id: string;
    appId: string;
    userId: string;
    tenantId?: string;
    accessToken: string;
    accessTokenExpiry?: number;
    refreshToken?: string;
    hasRefreshToken?: boolean;
    scopes?: string[];
    grantedBy?: string;
};
declare type ManagementFlowOptions = {
    input?: Record<string, any>;
    preview?: boolean;
};

interface PatchUserOptions {
    email?: string;
    phone?: string;
    displayName?: string;
    roles?: string[];
    userTenants?: AssociatedTenant[];
    customAttributes?: Record<string, AttributesTypes>;
    picture?: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    ssoAppIds?: string[];
    scim?: boolean;
}

/** Configuration arguments which include the Descope core SDK args and an optional management key */
declare type NodeSdkArgs = Parameters<typeof _descope_core_js_sdk__default>[0] & {
    managementKey?: string;
    authManagementKey?: string;
    publicKey?: string;
};
declare const nodeSdk: {
    ({ authManagementKey, managementKey, publicKey, ...config }: NodeSdkArgs): {
        refresh: (token?: string) => Promise<SdkResponse<JWTResponse & {
            refreshJwt?: string;
            cookies?: string[];
        }>>;
        management: {
            user: {
                create: {
                    (loginId: string, options?: UserOptions): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                createTestUser: {
                    (loginId: string, options?: UserOptions): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                invite: {
                    (loginId: string, options?: UserOptions & {
                        inviteUrl?: string;
                        sendMail?: boolean;
                        sendSMS?: boolean;
                        templateOptions?: TemplateOptions;
                        templateId?: string;
                    }): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, inviteUrl?: string, sendMail?: boolean, sendSMS?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[], templateId?: string): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                inviteBatch: (users: User[], inviteUrl?: string, sendMail?: boolean, sendSMS?: boolean, templateOptions?: TemplateOptions, templateId?: string) => Promise<SdkResponse<CreateOrInviteBatchResponse>>;
                createBatch: (users: User[]) => Promise<SdkResponse<CreateOrInviteBatchResponse>>;
                deleteBatch: (userIds: string[]) => Promise<SdkResponse<never>>;
                update: {
                    (loginId: string, options?: UserOptions): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                patch: (loginId: string, options: PatchUserOptions) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                delete: (loginId: string) => Promise<SdkResponse<never>>;
                deleteByUserId: (userId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                deleteAllTestUsers: () => Promise<SdkResponse<never>>;
                load: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                loadByUserId: (userId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                logoutUser: (loginId: string) => Promise<SdkResponse<never>>;
                logoutUserByUserId: (userId: string) => Promise<SdkResponse<never>>;
                searchAll: (tenantIds?: string[], roles?: string[], limit?: number, page?: number, testUsersOnly?: boolean, withTestUser?: boolean, customAttributes?: Record<string, AttributesTypes>, statuses?: UserStatus[], emails?: string[], phones?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                searchTestUsers: (searchReq: {
                    page?: number;
                    limit?: number;
                    sort?: {
                        field: string;
                        desc?: boolean;
                    }[];
                    text?: string;
                    emails?: string[];
                    phones?: string[];
                    statuses?: UserStatus[];
                    roles?: string[];
                    tenantIds?: string[];
                    customAttributes?: Record<string, AttributesTypes>;
                    withTestUser?: boolean;
                    testUsersOnly?: boolean;
                    ssoAppIds?: string[];
                    loginIds?: string[];
                    userIds?: string[];
                    fromCreatedTime?: number;
                    toCreatedTime?: number;
                    fromModifiedTime?: number;
                    toModifiedTime?: number;
                    tenantRoleIds?: Record<string, {
                        values: string[];
                        and?: boolean;
                    }>;
                    tenantRoleNames?: Record<string, {
                        values: string[];
                        and?: boolean;
                    }>;
                }) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                search: (searchReq: {
                    page?: number;
                    limit?: number;
                    sort?: {
                        field: string;
                        desc?: boolean;
                    }[];
                    text?: string;
                    emails?: string[];
                    phones?: string[];
                    statuses?: UserStatus[];
                    roles?: string[];
                    tenantIds?: string[];
                    customAttributes?: Record<string, AttributesTypes>;
                    withTestUser?: boolean;
                    testUsersOnly?: boolean;
                    ssoAppIds?: string[];
                    loginIds?: string[];
                    userIds?: string[];
                    fromCreatedTime?: number;
                    toCreatedTime?: number;
                    fromModifiedTime?: number;
                    toModifiedTime?: number;
                    tenantRoleIds?: Record<string, {
                        values: string[];
                        and?: boolean;
                    }>;
                    tenantRoleNames?: Record<string, {
                        values: string[];
                        and?: boolean;
                    }>;
                }) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                getProviderToken: (loginId: string, provider: string, providerTokenOptions?: ProviderTokenOptions) => Promise<SdkResponse<ProviderTokenResponse>>;
                activate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                deactivate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateLoginId: (loginId: string, newLoginId?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateEmail: (loginId: string, email: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePhone: (loginId: string, phone: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateDisplayName: (loginId: string, displayName?: string, givenName?: string, middleName?: string, familyName?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePicture: (loginId: string, picture: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateCustomAttribute: (loginId: string, attributeKey: string, attributeValue: AttributesTypes) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addSSOapps: (loginId: string, ssoAppIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setSSOapps: (loginId: string, ssoAppIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeSSOapps: (loginId: string, ssoAppIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                generateOTPForTestUser: (deliveryMethod: DeliveryMethodForTestUser, loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateOTPForTestResponse>>;
                generateMagicLinkForTestUser: (deliveryMethod: DeliveryMethodForTestUser, loginId: string, uri: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateMagicLinkForTestResponse>>;
                generateEnchantedLinkForTestUser: (loginId: string, uri: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>>;
                generateEmbeddedLink: (loginId: string, customClaims?: Record<string, any>, timeout?: number) => Promise<SdkResponse<GenerateEmbeddedLinkResponse>>;
                generateSignUpEmbeddedLink: (loginId: string, user?: {
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                    email?: string;
                }, emailVerified?: boolean, phoneVerified?: boolean, loginOptions?: _descope_core_js_sdk.LoginOptions, timeout?: number) => Promise<SdkResponse<GenerateEmbeddedLinkResponse>>;
                setTemporaryPassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                setActivePassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                setPassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                expirePassword: (loginId: string) => Promise<SdkResponse<never>>;
                removeAllPasskeys: (loginId: string) => Promise<SdkResponse<never>>;
                removeTOTPSeed: (loginId: string) => Promise<SdkResponse<never>>;
                history: (userIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserHistoryResponse[]>>;
            };
            project: {
                updateName: (name: string) => Promise<SdkResponse<never>>;
                updateTags: (tags: string[]) => Promise<SdkResponse<never>>;
                clone: (name: string, environment?: "production", tags?: string[]) => Promise<SdkResponse<CloneProjectResponse>>;
                listProjects: () => Promise<SdkResponse<Project[]>>;
                exportSnapshot: () => Promise<SdkResponse<ExportSnapshotResponse>>;
                importSnapshot: (request: ImportSnapshotRequest) => Promise<SdkResponse<never>>;
                validateSnapshot: (request: ValidateSnapshotRequest) => Promise<SdkResponse<ValidateSnapshotResponse>>;
                export: () => Promise<SdkResponse<Record<string, any>>>;
                import: (files: Record<string, any>) => Promise<SdkResponse<never>>;
            };
            accessKey: {
                create: (name: string, expireTime: number, roles?: string[], tenants?: AssociatedTenant[], userId?: string, customClaims?: Record<string, any>, description?: string, permittedIps?: string[]) => Promise<SdkResponse<CreatedAccessKeyResponse>>;
                load: (id: string) => Promise<SdkResponse<AccessKey>>;
                searchAll: (tenantIds?: string[]) => Promise<SdkResponse<AccessKey[]>>;
                update: (id: string, name: string, description?: string, roles?: string[], tenants?: AssociatedTenant[], customClaims?: Record<string, any>, permittedIps?: string[]) => Promise<SdkResponse<AccessKey>>;
                deactivate: (id: string) => Promise<SdkResponse<never>>;
                activate: (id: string) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
            };
            tenant: {
                create: (name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>, enforceSSO?: boolean, disabled?: boolean) => Promise<SdkResponse<CreateTenantResponse>>;
                createWithId: (id: string, name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>, enforceSSO?: boolean, disabled?: boolean) => Promise<SdkResponse<never>>;
                update: (id: string, name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>, enforceSSO?: boolean, disabled?: boolean) => Promise<SdkResponse<never>>;
                delete: (id: string, cascade?: boolean) => Promise<SdkResponse<never>>;
                load: (id: string) => Promise<SdkResponse<Tenant>>;
                loadAll: () => Promise<SdkResponse<Tenant[]>>;
                searchAll: (ids?: string[], names?: string[], selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<Tenant[]>>;
                getSettings: (tenantId: string) => Promise<SdkResponse<TenantSettings>>;
                configureSettings: (tenantId: string, settings: TenantSettings) => Promise<SdkResponse<never>>;
                generateSSOConfigurationLink: (tenantId: string, expireDuration: number, ssoId?: string, email?: string, templateId?: string) => Promise<SdkResponse<GenerateSSOConfigurationLinkResponse>>;
            };
            ssoApplication: {
                createOidcApplication: (options: OidcApplicationOptions) => Promise<SdkResponse<CreateSSOApplicationResponse>>;
                createSamlApplication: (options: SamlApplicationOptions) => Promise<SdkResponse<CreateSSOApplicationResponse>>;
                updateOidcApplication: (options: OidcApplicationOptions & {
                    id: string;
                }) => Promise<SdkResponse<never>>;
                updateSamlApplication: (options: SamlApplicationOptions & {
                    id: string;
                }) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
                load: (id: string) => Promise<SdkResponse<SSOApplication>>;
                loadAll: () => Promise<SdkResponse<SSOApplication[]>>;
            };
            inboundApplication: {
                createApplication: (options: InboundApplicationOptions) => Promise<SdkResponse<CreateInboundApplicationResponse>>;
                updateApplication: (options: InboundApplicationOptions & {
                    id: string;
                }) => Promise<SdkResponse<never>>;
                patchApplication: (options: Partial<InboundApplicationOptions> & {
                    id: string;
                }) => Promise<SdkResponse<never>>;
                deleteApplication: (id: string) => Promise<SdkResponse<never>>;
                loadApplication: (id: string) => Promise<SdkResponse<InboundApplication>>;
                loadAllApplications: () => Promise<SdkResponse<InboundApplication[]>>;
                getApplicationSecret: (id: string) => Promise<SdkResponse<InboundApplicationSecretResponse>>;
                rotateApplicationSecret: (id: string) => Promise<SdkResponse<never>>;
                searchConsents: (options?: InboundApplicationConsentSearchOptions) => Promise<SdkResponse<InboundApplicationConsent[]>>;
                deleteConsents: (options: InboundApplicationConsentDeleteOptions) => Promise<SdkResponse<never>>;
            };
            outboundApplication: {
                createApplication: (app: Omit<OutboundApplication, "id"> & Partial<Pick<OutboundApplication, "id">> & {
                    clientSecret?: string;
                }) => Promise<SdkResponse<OutboundApplication>>;
                updateApplication: (app: OutboundApplication & {
                    clientSecret?: string;
                }) => Promise<SdkResponse<OutboundApplication>>;
                deleteApplication: (id: string) => Promise<SdkResponse<never>>;
                loadApplication: (id: string) => Promise<SdkResponse<OutboundApplication>>;
                loadAllApplications: () => Promise<SdkResponse<OutboundApplication[]>>;
                fetchTokenByScopes: (appId: string, userId: string, scopes: string[], options?: FetchOutboundAppTokenOptions, tenantId?: string) => Promise<SdkResponse<OutboundAppToken>>;
                fetchToken: (appId: string, userId: string, tenantId?: string, options?: FetchOutboundAppTokenOptions) => Promise<SdkResponse<OutboundAppToken>>;
                fetchTenantTokenByScopes: (appId: string, tenantId: string, scopes: string[], options?: FetchOutboundAppTokenOptions) => Promise<SdkResponse<OutboundAppToken>>;
                fetchTenantToken: (appId: string, tenantId: string, options?: FetchOutboundAppTokenOptions) => Promise<SdkResponse<OutboundAppToken>>;
            };
            sso: {
                getSettings: (tenantId: string) => Promise<SdkResponse<SSOSettingsResponse>>;
                newSettings: (tenantId: string, ssoId: string, displayName: string) => Promise<SdkResponse<SSOSettings>>;
                deleteSettings: (tenantId: string, ssoId?: string) => Promise<SdkResponse<never>>;
                configureSettings: (tenantId: string, idpURL: string, idpCert: string, entityId: string, redirectURL: string, domains: string[]) => Promise<SdkResponse<never>>;
                configureMetadata: (tenantId: string, idpMetadataURL: string, redirectURL: string, domains: string[]) => Promise<SdkResponse<never>>;
                configureMapping: (tenantId: string, roleMappings?: RoleMappings, attributeMapping?: AttributeMapping) => Promise<SdkResponse<never>>;
                configureOIDCSettings: (tenantId: string, settings: SSOOIDCSettings, domains?: string[], ssoId?: string) => Promise<SdkResponse<never>>;
                configureSAMLSettings: (tenantId: string, settings: SSOSAMLSettings, redirectUrl?: string, domains?: string[], ssoId?: string) => Promise<SdkResponse<never>>;
                configureSAMLByMetadata: (tenantId: string, settings: SSOSAMLByMetadataSettings, redirectUrl?: string, domains?: string[], ssoId?: string) => Promise<SdkResponse<never>>;
                loadSettings: (tenantId: string, ssoId?: string) => Promise<SdkResponse<SSOSettings>>;
                loadAllSettings: (tenantId: string) => Promise<SdkResponse<SSOSettings[]>>;
            };
            jwt: {
                update: (jwt: string, customClaims?: Record<string, any>, refreshDuration?: number) => Promise<SdkResponse<UpdateJWTResponse>>;
                impersonate: (impersonatorId: string, loginId: string, validateConsent: boolean, customClaims?: Record<string, any>, selectedTenant?: string, refreshDuration?: number) => Promise<SdkResponse<UpdateJWTResponse>>;
                stopImpersonation: (jwt: string, customClaims?: Record<string, any>, selectedTenant?: string, refreshDuration?: number) => Promise<SdkResponse<UpdateJWTResponse>>;
                signIn: (loginId: string, loginOptions?: MgmtLoginOptions) => Promise<SdkResponse<JWTResponse>>;
                signUp: (loginId: string, user?: MgmtUserOptions, signUpOptions?: MgmtSignUpOptions) => Promise<SdkResponse<JWTResponse>>;
                signUpOrIn: (loginId: string, user?: MgmtUserOptions, signUpOptions?: MgmtSignUpOptions) => Promise<SdkResponse<JWTResponse>>;
                anonymous: (customClaims?: Record<string, any>, selectedTenant?: string, refreshDuration?: number) => Promise<SdkResponse<{
                    refreshJwt?: string;
                    cookieDomain?: string;
                    cookieMaxAge?: number;
                    cookiePath?: string;
                    sessionJwt: string;
                    cookieExpiration?: number;
                    sessionExpiration: number;
                }>>;
            };
            permission: {
                create: (name: string, description?: string) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string) => Promise<SdkResponse<never>>;
                delete: (name: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Permission[]>>;
            };
            password: {
                getSettings: (tenantId: string) => Promise<SdkResponse<PasswordSettings>>;
                configureSettings: (tenantId: string, settings: PasswordSettings) => Promise<SdkResponse<never>>;
            };
            role: {
                create: (name: string, description?: string, permissionNames?: string[], tenantId?: string, defaultRole?: boolean) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string, permissionNames?: string[], tenantId?: string, defaultRole?: boolean) => Promise<SdkResponse<never>>;
                delete: (name: string, tenantId?: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Role[]>>;
                search: (options: RoleSearchOptions) => Promise<SdkResponse<Role[]>>;
            };
            group: {
                loadAllGroups: (tenantId: string) => Promise<SdkResponse<Group[]>>;
                loadAllGroupsForMember: (tenantId: string, userIds: string[], loginIds: string[]) => Promise<SdkResponse<Group[]>>;
                loadAllGroupMembers: (tenantId: string, groupId: string) => Promise<SdkResponse<Group[]>>;
            };
            flow: {
                list: () => Promise<SdkResponse<FlowsResponse>>;
                delete: (flowIds: string[]) => Promise<SdkResponse<never>>;
                export: (flowId: string) => Promise<SdkResponse<FlowResponse>>;
                /** Configuration arguments which include the Descope core SDK args and an optional management key */
                import: (flowId: string, flow: Flow, screens?: Screen[]) => Promise<SdkResponse<FlowResponse>>;
                run: (flowId: string, options?: ManagementFlowOptions) => Promise<SdkResponse<Record<string, any>>>;
            };
            theme: {
                export: () => Promise<SdkResponse<ThemeResponse>>;
                import: (theme: Theme) => Promise<SdkResponse<ThemeResponse>>;
            };
            audit: {
                search: (searchOptions: AuditSearchOptions) => Promise<SdkResponse<AuditRecord[]>>;
                createEvent: (createOptions: AuditCreateOptions) => Promise<SdkResponse<never>>;
            };
            authz: {
                saveSchema: (schema: AuthzSchema, upgrade: boolean) => Promise<SdkResponse<never>>;
                deleteSchema: () => Promise<SdkResponse<never>>;
                loadSchema: () => Promise<SdkResponse<AuthzSchema>>;
                saveNamespace: (namespace: AuthzNamespace, oldName?: string, schemaName?: string) => Promise<SdkResponse<never>>;
                deleteNamespace: (name: string, schemaName?: string) => Promise<SdkResponse<never>>;
                saveRelationDefinition: (relationDefinition: AuthzRelationDefinition, namespace: string, oldName?: string, schemaName?: string) => Promise<SdkResponse<never>>;
                deleteRelationDefinition: (name: string, namespace: string, schemaName?: string) => Promise<SdkResponse<never>>;
                createRelations: (relations: AuthzRelation[]) => Promise<SdkResponse<never>>;
                deleteRelations: (relations: AuthzRelation[]) => Promise<SdkResponse<never>>;
                deleteRelationsForResources: (resources: string[]) => Promise<SdkResponse<never>>;
                deleteResourceRelationsForResources: (resources: string[]) => Promise<SdkResponse<never>>;
                deleteRelationsForIds: (ids: string[]) => Promise<SdkResponse<never>>;
                hasRelations: (relationQueries: AuthzRelationQuery[]) => Promise<SdkResponse<AuthzRelationQuery[]>>;
                whoCanAccess: (resource: string, relationDefinition: string, namespace: string) => Promise<SdkResponse<string[]>>;
                resourceRelations: (resource: string, ignoreTargetSetRelations?: boolean) => Promise<SdkResponse<AuthzRelation[]>>;
                targetsRelations: (targets: string[], includeTargetSetRelations?: boolean) => Promise<SdkResponse<AuthzRelation[]>>;
                whatCanTargetAccess: (target: string) => Promise<SdkResponse<AuthzRelation[]>>;
                whatCanTargetAccessWithRelation: (target: string, relationDefinition: string, namespace: string) => Promise<SdkResponse<AuthzResource[]>>;
                getModified: (since: Date) => Promise<SdkResponse<AuthzModified>>;
            };
            fga: {
                saveSchema: (schema: FGASchema) => Promise<SdkResponse<never>>;
                deleteSchema: () => Promise<SdkResponse<never>>;
                createRelations: (relations: FGARelation[]) => Promise<SdkResponse<never>>;
                deleteRelations: (relations: FGARelation[]) => Promise<SdkResponse<never>>;
                check: (relations: FGARelation[]) => Promise<SdkResponse<CheckResponseRelation[]>>;
                loadResourcesDetails: (resourceIdentifiers: FGAResourceIdentifier[]) => Promise<SdkResponse<FGAResourceDetails[]>>;
                saveResourcesDetails: (resourcesDetails: FGAResourceDetails[]) => Promise<SdkResponse<never>>;
                deleteAllRelations: () => Promise<SdkResponse<never>>;
            };
        };
        getKey: (header: JWTHeaderParameters) => Promise<KeyLike | Uint8Array>;
        validateJwt: (jwt: string) => Promise<AuthenticationInfo>;
        validateSession: (sessionToken: string) => Promise<AuthenticationInfo>;
        refreshSession: (refreshToken: string) => Promise<RefreshAuthenticationInfo>;
        validateAndRefreshSession: (sessionToken?: string, refreshToken?: string) => Promise<RefreshAuthenticationInfo>;
        exchangeAccessKey: (accessKey: string, loginOptions?: AccessKeyLoginOptions) => Promise<AuthenticationInfo>;
        validatePermissions: (authInfo: AuthenticationInfo, permissions: string[]) => boolean;
        getMatchedPermissions: (authInfo: AuthenticationInfo, permissions: string[]) => string[];
        validateTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => boolean;
        getMatchedTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => string[];
        validateRoles: (authInfo: AuthenticationInfo, roles: string[]) => boolean;
        getMatchedRoles: (authInfo: AuthenticationInfo, roles: string[]) => string[];
        validateTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => boolean;
        getMatchedTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => string[];
        accessKey: {
            exchange: (accessKey: string, loginOptions?: AccessKeyLoginOptions) => Promise<SdkResponse<ExchangeAccessKeyResponse>>;
        };
        otp: {
            verify: {
                sms: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                voice: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                whatsapp: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                email: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                sms: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                voice: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                voice: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                voice: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T extends boolean>(loginId: string, email: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T;
                    onMergeUseExisting?: T extends true ? boolean : never;
                    templateOptions?: {
                        [x: string]: string;
                    };
                    templateId?: string;
                    providerId?: string;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                        templateId?: string;
                        providerId?: string;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    voice: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                        templateId?: string;
                        providerId?: string;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                        templateId?: string;
                        providerId?: string;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        magicLink: {
            verify: (token: string) => Promise<SdkResponse<JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signIn: {
                sms: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                voice: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                voice: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                voice: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateId?: string;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T_2 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_2;
                    onMergeUseExisting?: T_2 extends true ? boolean : never;
                    templateOptions?: {
                        [x: string]: string;
                    };
                    templateId?: string;
                    providerId?: string;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                        templateId?: string;
                        providerId?: string;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    voice: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                        templateId?: string;
                        providerId?: string;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                        templateId?: string;
                        providerId?: string;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        enchantedLink: {
            verify: (token: string) => Promise<SdkResponse<never>>;
            signIn: (loginId: string, URI?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signUpOrIn: (loginId: string, URI?: string, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateId?: string;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            signUp: (loginId: string, URI?: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateId?: string;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            waitForSession: (pendingRef: string, config?: {
                pollingIntervalMs: number;
                timeoutMs: number;
            }) => Promise<SdkResponse<JWTResponse>>;
            update: {
                email: <T_4 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_4;
                    onMergeUseExisting?: T_4 extends true ? boolean : never;
                    templateOptions?: {
                        [x: string]: string;
                    };
                    templateId?: string;
                    providerId?: string;
                }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            };
        };
        oauth: {
            start: ((provider: string, redirectUrl?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string, loginHint?: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>) & {
                facebook: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                github: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                google: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                microsoft: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                gitlab: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                apple: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                discord: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                linkedin: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                slack: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            };
            exchange: (code: string) => Promise<SdkResponse<JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            startNative: (provider: string, loginOptions?: _descope_core_js_sdk.LoginOptions, implicit?: boolean) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            finishNative: (provider: string, stateId: string, user?: string, code?: string, idToken?: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            getOneTapClientId: (provider: string) => Promise<SdkResponse<{
                clientId: string;
            }>>;
            verifyOneTapIDToken: (provider: string, idToken: string, nonce: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<{
                code: string;
            }>>;
            exchangeOneTapIDToken: (provider: string, idToken: string, nonce: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<JWTResponse>>;
        };
        outbound: {
            connect: (appId: string, options?: {
                redirectUrl?: string;
                scopes?: string[];
            }, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
        };
        saml: {
            start: (tenantIdOrEmail: string, redirectUrl?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string, ssoId?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            exchange: (code: string) => Promise<SdkResponse<JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
        };
        totp: {
            signUp: (loginId: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
            verify: (loginId: string, code: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            update: (loginId: string, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
        };
        notp: {
            signUpOrIn: (loginId?: string, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateId?: string;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<{
                pendingRef: string;
                redirectUrl: string;
                image: string;
            }>>;
            signUp: (loginId?: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateId?: string;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<{
                pendingRef: string;
                redirectUrl: string;
                image: string;
            }>>;
            signIn: (loginId?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                pendingRef: string;
                redirectUrl: string;
                image: string;
            }>>;
            waitForSession: (pendingRef: string, config?: {
                pollingIntervalMs: number;
                timeoutMs: number;
            }) => Promise<SdkResponse<JWTResponse>>;
        };
        webauthn: {
            signUp: {
                start: (loginId: string, origin: string, name: string, passkeyOptions?: _descope_core_js_sdk.PasskeyOptions) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                start: (loginId: string, origin: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string, passkeyOptions?: _descope_core_js_sdk.PasskeyOptions) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signUpOrIn: {
                start: (loginId: string, origin: string, passkeyOptions?: _descope_core_js_sdk.PasskeyOptions) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
            };
            update: {
                start: (loginId: string, origin: string, token?: string, passkeyOptions?: _descope_core_js_sdk.PasskeyOptions) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            };
        };
        password: {
            signUp: (loginId: string, password: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateId?: string;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<JWTResponse>>;
            signIn: (loginId: string, password: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<JWTResponse>>;
            sendReset: (loginId: string, redirectUrl?: string, templateOptions?: {
                [x: string]: string;
            }) => Promise<SdkResponse<{
                resetMethod: string;
                pendingRef?: string;
                linkId?: string;
                maskedEmail: string;
            }>>;
            update: (loginId: string, newPassword: string, token?: string) => Promise<SdkResponse<never>>;
            replace: (loginId: string, oldPassword: string, newPassword: string) => Promise<SdkResponse<JWTResponse>>;
            policy: () => Promise<SdkResponse<{
                minLength: number;
                lowercase: boolean;
                uppercase: boolean;
                number: boolean;
                nonAlphanumeric: boolean;
            }>>;
        };
        flow: {
            start: (flowId: string, options?: {
                redirectUrl?: string;
                location?: string;
                tenant?: string;
                deviceInfo?: {
                    webAuthnSupport?: boolean;
                };
                lastAuth?: {
                    authMethod?: "saml" | "otp" | "oauth" | "totp" | "webauthn" | "magiclink" | "enchantedlink";
                    oauthProvider?: string;
                    name?: string;
                    loginId?: string;
                };
                redirectAuth?: {
                    callbackUrl: string;
                    codeChallenge: string;
                };
                oidcIdpStateId?: string;
                preview?: boolean;
                samlIdpStateId?: string;
                samlIdpUsername?: string;
                ssoAppId?: string;
                thirdPartyAppId?: string;
                oidcLoginHint?: string;
                abTestingKey?: number;
                startOptionsVersion?: number;
                client?: Record<string, any>;
                locale?: string;
                oidcPrompt?: string;
                oidcErrorRedirectUri?: string;
                oidcResource?: string;
                nativeOptions?: {
                    platform: "ios" | "android";
                    oauthProvider?: string;
                    oauthRedirect?: string;
                };
                thirdPartyAppStateId?: string;
                applicationScopes?: string;
                outboundAppId?: string;
                outboundAppScopes?: string[];
            }, conditionInteractionId?: string, interactionId?: string, componentsVersion?: string, flowVersions?: Record<string, number>, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
            next: (executionId: string, stepId: string, interactionId: string, version?: number, componentsVersion?: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
        };
        selectTenant: (tenantId: string, token?: string) => Promise<SdkResponse<JWTResponse>>;
        logout: (token?: string) => Promise<SdkResponse<never>>;
        logoutAll: (token?: string) => Promise<SdkResponse<never>>;
        me: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
        myTenants: (tenants: true | string[], token?: string) => Promise<SdkResponse<{
            tenants: {
                id: string;
                name: string;
                customAttributes?: Record<string, any>;
            }[];
        }>>;
        history: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserHistoryResponse>>;
        isJwtExpired: (token: string) => boolean;
        getTenants: (token: string) => string[];
        getJwtPermissions: (token: string, tenant?: string) => string[];
        getJwtRoles: (token: string, tenant?: string) => string[];
        getCurrentTenant: (token: string) => string;
        httpClient: _descope_core_js_sdk.HttpClient;
    };
    /** Descope SDK client with delivery methods enum.
     *
     * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}
     * @example Usage
     *
     * ```js
     * import descopeSdk from '@descope/node-sdk';
     *
     * const myProjectId = 'xxx';
     * const sdk = descopeSdk({ projectId: myProjectId });
     *
     * const userLoginId = 'loginId';
     * sdk.otp.signIn.email(userLoginId);
     * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);
     * ```
     */
    RefreshTokenCookieName: string;
    SessionTokenCookieName: string;
    DescopeErrors: {
        badRequest: string;
        missingArguments: string;
        invalidRequest: string;
        invalidArguments: string;
        wrongOTPCode: string;
        tooManyOTPAttempts: string;
        enchantedLinkPending: string;
        userNotFound: string;
    };
};

export { AuthenticationInfo, nodeSdk as default };
